---
title: "Multi-Trial Analysis Report"
author: ""
date: "2023-11-03"
output: html_document
params:
  toDownload: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, error = FALSE)
font.plot_ly <- list(family="Courier New, monospace", size=9)
```

```{r printfxn, include=FALSE}
# functions ####
# for printing tables (data.frames) - DT::datatable()
printTable <- function(DT, pageLength = 7, 
                       numericColNames = NULL, numRound = 3, ...) {
  
  DT <- data.frame(lapply(X = DT, 
                          FUN = function(x) {
                            if(is.numeric(x)){
                              round(x, numRound)
                            } else {
                              x
                            }
                          }))
  
  table <- DT::datatable(data = DT, 
                         filter = "top", 
                         options = list(autoWidth = TRUE, 
                                        dom = 'l<<t>pB>', 
                                        buttons = c('copy', 'excel'),
                                        pageLength = pageLength,
                                        searchHighlight = TRUE,
                                        lengthMenu = c(7, 14, 21, 28, 35)),
                         extensions = 'Buttons',
                         rownames = FALSE,
                         ...)
  if (length(numericColNames) > 0){
    table <- table %>% formatRound(columns = numericColNames,
                                   digits = numRound)
  }
  
  table
}
```

```{r plot_init, include = FALSE}
# Init Step to make sure that the dependencies are loaded
# was done to enable proper printing of the tab header and the graphs within the for loop below using print(htmltools::tagList(ggplotly(...)))
library(ggplot2)
htmltools::tagList(plotly::ggplotly(ggplot2::ggplot()))
htmltools::tagList(printTable(mtcars))
# Get the current figure size in pixels:
get_w <- function() {
  with(knitr::opts_current$get(c("fig.width", "dpi", "fig.retina")),
       fig.width*dpi/fig.retina)
}

get_h <- function() {
  with(knitr::opts_current$get(c("fig.height", "dpi", "fig.retina")),
       fig.height*dpi/fig.retina)
}

```

```{r }

suppressWarnings(tryCatch({
  if(file.exists("./outputs/result.RData")){
    load("./outputs/resultMta.RData")
  }else{
    load("resultMta.RData")
  }
}, error = function(e) {
  # NULL
}))

if (is.null(result)){
  # invisible(NULL)
} else {
  # result$status <- result$status[1:6,]
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
  modeling <- result$modeling
  modelingFieldsIncludedInMta <- modeling[modeling$analysisId == idMta & modeling$parameter == "includedInMta", ]
}
```

### By environment merit distribution

The following boxplot allows to see the distribution of predicted values (y-axis) in the different environments for each **trait**. At the top of each boxplot the reliability (r2) for that environment by trait combination can be reviewed.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitMta"), 
                label = "", 
                choices = traits
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  idSta <- result$modeling[result$modeling$analysisId == idMta & result$modeling$trait == "inputObject","value"]
  # predictions
  pred.sta <- result$predictions
  pred.sta <- pred.sta[pred.sta$analysisId == idSta,]
  pred.sta.boxplot <- subset(pred.sta, select = c(trait,designation,environment,predictedValue))
  # reliabilities
  r2Sta <- result$metrics[result$metrics$analysisId==idSta & result$metrics$parameter == "r2",]
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###  {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == iTrait, "environment"]
      temp.pred.box <- pred.sta.boxplot[pred.sta.boxplot$trait==iTrait & pred.sta.boxplot$environment %in% goodFields,]
      meansEnv <- aggregate(predictedValue~environment, data=temp.pred.box, FUN=mean, na.rm=TRUE); colnames(meansEnv)[2] <- "envMean"
      temp.pred.box <- merge(temp.pred.box,meansEnv, by="environment", all.x = TRUE) # merge env means
      temp.r2Sta <- r2Sta[r2Sta$trait ==iTrait & r2Sta$environment %in% goodFields, ] # reliabilities
      temp.pred.box <- merge(temp.pred.box,temp.r2Sta[,c("environment","value")], by="environment", all.x = TRUE) # merge reliabilities
      p <- temp.pred.box %>%
        ggplot2::ggplot() +
        ggplot2::aes(x=envMean, y=predictedValue, fill = environment) +
        ggplot2::geom_boxplot() +
        ggplot2::labs(x = "Environmental mean", y = "Trait value") +
        ggplot2::scale_fill_discrete(name = "") +
        ggplot2::theme(legend.position = "bottom")  +
        ggplot2::guides(fill=guide_legend(nrow=3,byrow=TRUE)) +
        ggplot2::geom_text(data=temp.pred.box,aes(x= envMean, y = max(predictedValue) , label =round(value,2) ), position=position_dodge(width = 0.8),size = 3, vjust = 0.5,colour="black") 
      
      # if(length(unique(temp.pred.box$designation)) > 200){ # go fixed format
      print(p)
      # }else{ # go dynamic
      #   print(htmltools::tagList(plotly::ggplotly(p)))
      # }
      
    }
    
  } else{ # display in website
    
    if(length(unique(pred$designation)) > 200){ # go fixed format
      shiny::renderPlot({
        goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == input$traitMta, "environment"]
        temp.pred.box <- pred.sta.boxplot[pred.sta.boxplot$trait==input$traitMta & pred.sta.boxplot$environment %in% goodFields,]
        meansEnv <- aggregate(predictedValue~environment, data=temp.pred.box, FUN=mean, na.rm=TRUE); colnames(meansEnv)[2] <- "envMean"
        temp.pred.box <- merge(temp.pred.box,meansEnv, by="environment", all.x = TRUE)
        temp.r2Sta <- r2Sta[r2Sta$trait ==input$traitMta & r2Sta$environment %in% goodFields, ] # reliabilities
        temp.pred.box <- merge(temp.pred.box,temp.r2Sta[,c("environment","value")], by="environment", all.x = TRUE) # merge reliabilities
        p <- temp.pred.box %>%
          ggplot() +
          aes(x=envMean, y=predictedValue, fill = environment) +
          geom_boxplot() +
          labs(x = "Environmental mean", y = "Trait value") +
          scale_fill_discrete(name = "") +
          theme(legend.position = "bottom") +
          guides(fill=guide_legend(nrow=3,byrow=TRUE)) +
          ggplot2::geom_text(data=temp.pred.box,aes(x= envMean, y = max(predictedValue) , label =round(value,2) ), position=position_dodge(width = 0.8),size = 5, vjust = 0.5,colour="black")
        p
      })
    } else { # go dynamic
      plotly::renderPlotly({
        goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == input$traitMta, "environment"]
        temp.pred.box <- pred.sta.boxplot[pred.sta.boxplot$trait==input$traitMta & pred.sta.boxplot$environment %in% goodFields,]
        meansEnv <- aggregate(predictedValue~environment, data=temp.pred.box, FUN=mean, na.rm=TRUE); colnames(meansEnv)[2] <- "envMean"
        temp.pred.box <- merge(temp.pred.box,meansEnv, by="environment", all.x = TRUE)
        p <- plotly::plot_ly( data = temp.pred.box, y = ~predictedValue,
                              x = ~envMean,  type = "box", color = ~environment
        ) %>%  plotly::layout( font=font.plot_ly,
                               xaxis=list( title="Environmental mean"), yaxis=list( title="Trait value") )
        p
      })
      
    }
  }
  
}
```

### Connectivity between environments

The following heatmap allows the user to review the connectivity (gennotypes in common) between different environments.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitMtaConnect"), 
                label = "", 
                choices = traits
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  mydata <- result$predictions # extract predictions
  
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###  {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == iTrait, "environment"]
      mydata2 <- mydata[which(mydata$trait == iTrait & mydata$environment %in% goodFields), ]
      splitAggregate <- with(mydata2,  split(mydata2[,"designation"],mydata2[,"environment"]) ) # split by environment
      splitAggregate <- lapply(splitAggregate,unique); nag <- length(splitAggregate) # get unique individual names
      nagm <- matrix(0,nag,nag); rownames(nagm) <- colnames(nagm) <- names(splitAggregate) # prefilled matrix
      for(i in 1:length(splitAggregate)){ # fill the matrix of intersection of individuals between pair of environments
        for(j in 1:i){
          nagm[i,j] <- length(intersect(splitAggregate[[i]],splitAggregate[[j]]))
        }
      }
      nagm[upper.tri(nagm)] <- t(nagm)[upper.tri(nagm)] # fill the upper triangular
      
      mydata4 <- cgiarBase::matToTab(nagm) # matrix to a dataframe for plot
      maxVal <- max(nagm, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "firebrick", high = "#038542", mid = "gold",
                                      midpoint = 60, limit = c(0,maxVal), space = "Lab",
                                      name="Connectivity") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() + 
        ggplot2::coord_fixed() + ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 7, hjust = 1, color="black"))+
        ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 7, hjust = 1, color="black"))
      if(nrow(nagm) < 20){ # if user wants to add text to the cells
        p <- p + ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 4)
      }
      print(p)
      
    }
    
  } else{ # display in website
    
    shiny::renderPlot({
      
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == input$traitMtaConnect, "environment"]
      mydata2 <- mydata[which(mydata$trait == input$traitMtaConnect & mydata$environment %in% goodFields), ]
      splitAggregate <- with(mydata2,  split(mydata2[,"designation"],mydata2[,"environment"]) ) # split by environment
      splitAggregate <- lapply(splitAggregate,unique); nag <- length(splitAggregate) # get unique individual names
      nagm <- matrix(0,nag,nag); rownames(nagm) <- colnames(nagm) <- names(splitAggregate) # prefilled matrix
      for(i in 1:length(splitAggregate)){ # fill the matrix of intersection of individuals between pair of environments
        for(j in 1:i){
          nagm[i,j] <- length(intersect(splitAggregate[[i]],splitAggregate[[j]]))
        }
      }
      nagm[upper.tri(nagm)] <- t(nagm)[upper.tri(nagm)] # fill the upper triangular
      
      mydata4 <- cgiarBase::matToTab(nagm) # matrix to a dataframe for plot
      maxVal <- max(nagm, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "firebrick", high = "#038542", mid = "gold",
                                      midpoint = 60, limit = c(0,maxVal), space = "Lab",
                                      name="Connectivity") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() + 
        ggplot2::coord_fixed() + ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 7, hjust = 1, color="black", face = "bold"))+
        ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 7, hjust = 1, color="black", face="bold"))
      if(nrow(nagm) < 20){ # if user wants to add text to the cells
        p <- p + ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 4)
      }
      print(p)
    })
    
  }
  
}
```

### Genetic correlations between environments

The following graph allows to see the genetic correlations among the different environment one **trait** at a time. If the user modeled GxE, this matrix is calculated as the correlation between the environment-specific estimates for individuals. If a pure main-effect model is specified this matrix is calculated as the correlation between the single-trial analysis estimates.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"])# unique(pred$trait)
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitPredictionsCorrelation"),
                label = "",
                choices = traits
    )
  }
  
}

```


```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  idSta <- result$modeling[result$modeling$analysisId == idMta & result$modeling$trait == "inputObject","value"]
  pred.sta <- result$predictions
  pred.sta <- pred.sta[pred.sta$analysisId == idSta,]
  # traits <- unique(pred.sta$trait)
  predictions.gcorrE <- subset(pred.sta, select = c(trait,designation,environment,predictedValue))
  envs <- unique(predictions.gcorrE[,"environment"])
  addTextInPlots <- ifelse(length(envs) > 30, FALSE, TRUE)
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      # p.cor.pred.env <- corPlotPredictions(predictions.gcorrE, iTrait, unitOfCorrelation="designation", correlatedAcross="environment", valueForCorrelation ="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots, checkboxAxis= addTextInPlots)
      # print(htmltools::tagList(plotly::ggplotly(p.cor.pred.env)))
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == iTrait, "environment"]
      predictions.gcorrE2 <- predictions.gcorrE[predictions.gcorrE$trait == iTrait & predictions.gcorrE$environment %in% goodFields , ]
      wide <- stats::reshape(predictions.gcorrE2,
                             direction = "wide", idvar = "designation",
                             timevar = "environment", v.names = "predictedValue", sep= "")
      colnames(wide) <- gsub("predictedValue","",colnames(wide))
      wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
      corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
      mydata4 <- cgiarBase::matToTab(corr)
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white",
                                      midpoint = 0, limit = c(-1,1), space = "Lab",
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() + 
        ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black"), 
                       axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1))
      if(nrow(corr) < 20){ # if user wants to fill cell values
        p <- p + ggplot2::geom_text(ggplot2::aes(label = round(Freq,2) ), color = "black", size = 4)
      }
      print(p)
      
    }
    
  }else{
    
    # plotly::renderPlotly({
    # p.cor.pred.env <- corPlotPredictions(predictions.gcorrE, input$traitPredictionsCorrelation, unitOfCorrelation="designation", correlatedAcross="environment",
    #                                      valueForCorrelation="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots,
    #                                      checkboxAxis= addTextInPlots)
    # plotly::layout(p.cor.pred.env,font=font.plot_ly)
    shiny::renderPlot({
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == input$traitPredictionsCorrelation, "environment"]
      predictions.gcorrE2 <- predictions.gcorrE[predictions.gcorrE$trait == input$traitPredictionsCorrelation & predictions.gcorrE$environment %in% goodFields , ]
      wide <- stats::reshape(predictions.gcorrE2,
                             direction = "wide", idvar = "designation",
                             timevar = "environment", v.names = "predictedValue", sep= "")
      colnames(wide) <- gsub("predictedValue","",colnames(wide))
      wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
      corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
      mydata4 <- cgiarBase::matToTab(corr)
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white",
                                      midpoint = 0, limit = c(-1,1), space = "Lab",
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() +
        ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black"), 
                       axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1) )
      if(nrow(corr) < 20){ # if user wants to fill cell values
        p <- p + ggplot2::geom_text(ggplot2::aes(label = round(Freq,2) ), color = "black", size = 4)
      }
      p
      # plotly::ggplotly(p)
    })
    
    
  }
  
}
```

<p>&nbsp;</p>

### Biplot by trait

The following graph allows to see the performance of the genotypes over the enevironments for each **trait**.

<p>&nbsp;</p>

```{r}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred.mta <- result$predictions
  pred.mta <- pred.mta[pred.mta$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred.mta$trait)
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitBiplot"),
                label = "",
                choices = traits
    )
  }
}

```

```{r, results='asis'}

if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  idSta <- result$modeling[result$modeling$analysisId == idMta & result$modeling$trait == "inputObject","value"]
  pred.sta <- result$predictions
  pred.sta <- pred.sta[pred.sta$analysisId == idSta,]
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == iTrait, "environment"]
      pred.mta.biplot <- reshape(pred.sta[which(pred.sta$trait == iTrait & pred.sta$environment %in% goodFields ),c("designation","environment","predictedValue")], 
                                 direction = "wide", idvar = "designation", timevar = "environment")
      
      rownames(pred.mta.biplot) <- pred.mta.biplot[,"designation"]
      pred.mta.biplot <- pred.mta.biplot[,-1]
      names(pred.mta.biplot) <- gsub("predictedValue.","",names(pred.mta.biplot))
      
      # keep only 
      missing <- apply(pred.mta.biplot,1, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[which(missing < 0.8),]
      missing <- apply(pred.mta.biplot,2, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[,which(missing < 0.8)]
      pred.mta.biplot <- apply(pred.mta.biplot,2, sommer::imputev)
      # pred.mta.biplot <- na.omit(pred.mta.biplot[,2:min(c(ncol(pred.mta.biplot),5))])
      prin_comp <- prcomp(pred.mta.biplot, rank = 2)
      components <- prin_comp[["x"]]
      components <- data.frame(components)
      components$PC2 <- -components$PC2
      
      explained_variance <- summary(prin_comp)[["sdev"]]
      explained_variance <- explained_variance[1:2]
      comp <- prin_comp[["rotation"]]
      comp[,'PC2'] <- - comp[,'PC2']
      loadings <- comp
      for (i in seq(explained_variance) ){
        loadings[,i] <- comp[,i] * explained_variance[i]
      }
      p.mta.biplot <- plotly::plot_ly (type = 'scatter', mode = 'markers')
      p.mta.biplot <- plotly::add_trace(p.mta.biplot, 
                                        x=components$PC1,
                                        y=components$PC2,
                                        text=rownames(components),
                                        marker=list(color="blue"),
                                        hoverinfo='text',
                                        showlegend=FALSE
      )
      for (i in 1:ncol(pred.mta.biplot)){
        p.mta.biplot <- p.mta.biplot %>%
          plotly::add_segments(x = 0, xend = loadings[i, 1], y = 0, yend = loadings[i, 2], line = list(color = 'red'),inherit = FALSE, showlegend = FALSE)
        if(ncol(pred.mta.biplot) < 20){
          p.mta.biplot <- p.mta.biplot %>%
            plotly::add_annotations(x=loadings[i, 1], y=loadings[i, 2], ax = 0, ay = 0,text = rownames(loadings)[i], xanchor = 'center', yanchor= 'bottom')
        }
      }
      print(htmltools::tagList(plotly::ggplotly(p.mta.biplot)))
      
    }
    
  }else{
    
    plotly::renderPlotly({
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == input$traitBiplot, "environment"]
      pred.mta.biplot <- reshape(pred.sta[which(pred.sta$trait == input$traitBiplot & pred.sta$environment %in% goodFields ),c("designation","environment","predictedValue")], 
                                 direction = "wide", idvar = "designation", timevar = "environment")
      
      rownames(pred.mta.biplot) <- pred.mta.biplot[,"designation"]
      pred.mta.biplot <- pred.mta.biplot[,-1]
      names(pred.mta.biplot) <- gsub("predictedValue.","",names(pred.mta.biplot))
      
      # keep only 
      missing <- apply(pred.mta.biplot,1, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[which(missing < 0.8),]
      missing <- apply(pred.mta.biplot,2, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[,which(missing < 0.8)]
      pred.mta.biplot <- apply(pred.mta.biplot,2, sommer::imputev)
      # pred.mta.biplot <- na.omit(pred.mta.biplot[,2:min(c(ncol(pred.mta.biplot),5))])
      
      prin_comp <- prcomp(pred.mta.biplot, rank = 2)
      components <- prin_comp[["x"]]
      components <- data.frame(components)
      components$PC2 <- -components$PC2
      
      explained_variance <- summary(prin_comp)[["sdev"]]
      explained_variance <- explained_variance[1:2]
      comp <- prin_comp[["rotation"]]
      comp[,'PC2'] <- - comp[,'PC2']
      loadings <- comp
      for (i in seq(explained_variance) ){
        loadings[,i] <- comp[,i] * explained_variance[i]
      }
      
      p.mta.biplot <- plotly::plot_ly (type = 'scatter', mode = 'markers')
      p.mta.biplot <- plotly::add_trace(p.mta.biplot, 
                                        x=components$PC1,
                                        y=components$PC2,
                                        text=rownames(components),
                                        marker=list(color="blue"),
                                        hoverinfo='text',
                                        showlegend=FALSE
      )
      
      
      for (i in 1:ncol(pred.mta.biplot)){
        p.mta.biplot <- p.mta.biplot %>%
          plotly::add_segments(x = 0, xend = loadings[i, 1], y = 0, yend = loadings[i, 2], line = list(color = 'red'),inherit = FALSE, showlegend = FALSE)
        if(ncol(pred.mta.biplot) < 20){
          p.mta.biplot <- p.mta.biplot %>%
            plotly::add_annotations(x=loadings[i, 1], y=loadings[i, 2], ax = 0, ay = 0,text = rownames(loadings)[i], xanchor = 'center', yanchor= 'bottom')
        }
      }
      plotly::layout(p.mta.biplot,font=font.plot_ly)
    })
    
  }
  
}
```


<p>&nbsp;</p>

### Across-environment metrics

The following barplot aims to help you check the across environment estimates for multiple parameters from the multi-trial analysis.

```{r}
if (is.null(result)){
  # invisible(NULL)
  cat(".")
} else {
  myMetrics <- result$metrics
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"];
  idMta <- idMta[length(idMta)]
  parameters <- myMetrics[which(myMetrics$analysisId == idMta),"parameter"]
  parameters <- setdiff(unique(parameters),"CV")
  
  if("params" %in% ls()){  # if user will download the report
    
  }else{
    shiny::selectInput(ns("parameterMetrics2"), 
                       label = "Parameter:", 
                       multiple = FALSE,
                       selected = parameters,
                       choices = parameters
    )
  }
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  myMetrics2 <- myMetrics[which(myMetrics$analysisId %in% idMta),]
  myMetrics2$value <- ifelse( myMetrics2$value < 0, 0,  myMetrics2$value )
  
  if("params" %in% ls()){  # if user will download the report
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    counter <- 1
    for(iParam in parameters){
      cat("\n\n####", iParam, "{.tabset .tabset-pills}       \n\n")
      
      mydata2 = myMetrics2[which(myMetrics2$parameter %in% iParam),]
      p <- ggplot(data=mydata2, ggplot2::aes(x=trait, y=value, fill=trait)) +
        ggplot2::geom_bar(stat="identity", position=ggplot2::position_dodge()) +
        ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black"), 
                       axis.text.x = ggplot2::element_text(angle = 45), legend.position = "bottom") +
        ggplot2::labs(x="Trait", y="Parameter value")
      print(p)
      cat("\n")
    }
    cat("\n")
  }else{ # display in website
    
    shiny::renderPlot({
      mydata2 = myMetrics2[which(myMetrics2$parameter %in% input$parameterMetrics2),]
      p <- ggplot2::ggplot(data=mydata2, ggplot2::aes(x=trait, y=value, fill=trait)) +
        ggplot2::geom_bar(stat="identity", position=ggplot2::position_dodge()) +
        ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black"), 
                       axis.text.x = ggplot2::element_text(angle = 45), legend.position = "bottom") +
        ggplot2::labs(x="Trait", y="Parameter value") 
      p
    })
    
  }
  
}
```

<p>&nbsp;</p>


### Variance component proportions for traits (across environments)

The following graph allows to see the proportion of variance going to different components. Above the bars you can see the value of the variance component for each factor.

<p>&nbsp;</p>


```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  idMtaVC <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMtaVC <- idMtaVC[length(idMtaVC)]
  traitsvc <- unique(result$modeling[which(result$modeling$analysisId == idMtaVC  & result$modeling$environment == "across"),"trait"])
  covariatesvc <- unique(result$metadata$weather$trait)
  df2 <- result$metrics
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"];
  idMta <- idMta[length(idMta)]
  df2 <- df2[df2$analysisId==idMta,]
  df2 <- df2[df2$parameter %in% c("Vg","Vr","Vp"), ]
  df2$traitOriginal <-  df2$trait
  for(iCov in covariatesvc){
    df2$traitOriginal <- gsub(paste0("-",iCov),"",df2$traitOriginal)
    df2$traitOriginal <- gsub(paste0(iCov),"",df2$traitOriginal)
    df2$traitOriginal <- gsub("_QTL","",df2$traitOriginal) # remove the QTL legend in this particular case
  }
  df2$parameterOriginal <- df2$trait
  for(iCov in traitsvc){ df2$parameterOriginal <- gsub(iCov,"",df2$parameterOriginal)}
  df2$parameterOriginal <- paste0(df2$parameter, df2$parameterOriginal)
  df2$value[which(df2$value < 0)]=0
  total <- try( aggregate(value~traitOriginal, FUN = sum, data=df2), silent = TRUE)
  if(!inherits(total, "try-error")){
    colnames(total)[2] <- "totalVar"
    df3 <- merge(df2,total, by=c("traitOriginal") )
  }else{df3 <- df2; df3$totalVar <- NA}
  df3$valueProp <- df3$value/df3$totalVar
  df3$valuePropCum <- NA; 
  for(iRow in nrow(df3):1){
    df3$valuePropCum[iRow] <- sum(df3$valueProp[nrow(df3):iRow])
  }
  df3$valuePropCum <- df3$valuePropCum - (ceiling(df3$valuePropCum) - 1)
  
  
  if("params" %in% ls()){ # we will download the document
    cat("\n\n###  {.tabset .tabset-pills}       \n\n")
    # for (j in 1:length(traitsvc)){
    #   cat("\n\n####", traitsvc[j], "{.tabset .tabset-pills}       \n\n")
    # df4 <- df3[df3$traitOriginal == traitsvc[j],]
    p <- ggplot2::ggplot(data=df3, ggplot2::aes(x=traitOriginal, y=valueProp, fill=parameterOriginal)) +
      ggplot2::geom_bar(stat="identity") +
      ggplot2::xlab("Traits") + ggplot2::ylab("Proportion of variance") +
      ggplot2::scale_fill_brewer(palette="Accent") +
      ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45)) +
      ggplot2::geom_hline(yintercept = seq(0.25,0.75,0.25), linetype = 3, colour = 'red') +
      ggplot2::geom_text(data=df3,ggplot2::aes(x= traitOriginal, y = valuePropCum , label =round(value,2) ),
                         position=ggplot2::position_dodge(width = 0.8),size = 3, vjust = -0.5 ,colour="black")
    print(p)
    # cat("\n")
    # }
    cat("\n")
  }else{
    
    shiny::renderPlot({
      p <- ggplot2::ggplot(data=df3, ggplot2::aes(x=traitOriginal, y=valueProp, fill=parameterOriginal)) +
        ggplot2::geom_bar(stat="identity") +
        ggplot2::xlab("Traits") + ggplot2::ylab("Proportion of variance") +
        ggplot2::scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45)) +
        ggplot2::geom_hline(yintercept = seq(0.25,0.75,0.25), linetype = 3, colour = 'red') +
        ggplot2::geom_text(data=df3,ggplot2::aes(x= traitOriginal, y = valuePropCum , label =round(value,2) ),
                           position=ggplot2::position_dodge(width = 0.8),size = 3, vjust = -0.5 ,colour="black")
      p
    })
  }
  
}
```

<p>&nbsp;</p>

### Across-environment merit estimates

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  result$status <- result$status#[1:6,]
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(pred$trait)
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitMta2"),
                label = "",
                choices = traits
    )
  }
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      temp.pred.box <- pred[pred$trait== iTrait,]
      
      p <- ggplot2::ggplot(
        data = temp.pred.box, 
        mapping = ggplot2::aes(
          x = reorder(designation, -predictedValue),
          y = predictedValue,
          col = entryType,
          text = paste(
            paste0('<br>', "designation: ", designation),
            paste0('<br>', "entry type: ", entryType),
            paste0('<br>', "predicted value: ", round(predictedValue, 4)),
            paste0('<br>', "standard error: ", round(stdError, 4)),
            # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ", 
            #        round(predictedValue + CI, 2), ")")))) +
            paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ", 
                   round(predictedValue + stdError, 4), ")")))) +
        ggplot2::theme_classic() +  ggplot2::geom_point() +
        ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                            ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                               width = 0.10) +
        ggplot2::labs(title = "across", x = "designation", y = "predicted value", col = "entry type") +
        ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7), legend.position = "bottom") +
        guides(fill=guide_legend(nrow=3,byrow=TRUE))
      # if(length(unique(temp.pred.box$designation)) > 200){ # go fixed format
      print(p)
      # }else{ # go dynamic
      # print(htmltools::tagList(plotly::ggplotly(p)))
      # }
    }
    
  }else{
    
    # if(length(unique(pred$designation)) > 200){ # go fixed format
      
      shiny::renderPlot({
        
        temp.pred.box <- pred[pred$trait== input$traitMta2,]
        p <- ggplot2::ggplot(
          data = temp.pred.box,
          mapping = ggplot2::aes(
            x = reorder(designation, -predictedValue),
            y = predictedValue,
            col = entryType,
            text = paste(
              paste0('<br>', "designation: ", designation),
              paste0('<br>', "entry type: ", entryType),
              paste0('<br>', "predicted value: ", round(predictedValue, 4)),
              paste0('<br>', "standard error: ", round(stdError, 4)),
              # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ",
              #        round(predictedValue + CI, 2), ")")))) +
              paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ",
                     round(predictedValue + stdError, 4), ")")))) +
          ggplot2::theme_classic() +  ggplot2::geom_point() +
          ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                              ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                                 width = 0.10) +
          ggplot2::labs(title = "across", x = "designation", y = "predicted value", col = "entry type") +
          ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7, face = "bold"), legend.position = "bottom") + ggplot2::guides(fill=guide_legend(nrow=3,byrow=TRUE))
        p
        
      })
    # }else{ # go dynamic
    #   plotly::renderPlotly({
    #     
    #     temp.pred.box <- pred[pred$trait== input$traitMta2,]
    #     p <- ggplot2::ggplot(
    #       data = temp.pred.box,
    #       mapping = ggplot2::aes(
    #         x = reorder(designation, -predictedValue),
    #         y = predictedValue,
    #         col = entryType,
    #         text = paste(
    #           paste0('<br>', "designation: ", designation),
    #           paste0('<br>', "entry type: ", entryType),
    #           paste0('<br>', "predicted value: ", round(predictedValue, 4)),
    #           paste0('<br>', "standard error: ", round(stdError, 4)),
    #           # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ",
    #           #        round(predictedValue + CI, 2), ")")))) +
    #           paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ",
    #                  round(predictedValue + stdError, 4), ")")))) +
    #       ggplot2::theme_classic() +  ggplot2::geom_point() +
    #       ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
    #                                           ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
    #                              width = 0.10) +
    #       ggplot2::labs(title = "across", x = "designation", y = "predicted value", col = "entry type") +
    #       ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7), legend.position = "bottom") + ggplot2::guides(fill=guide_legend(nrow=3,byrow=TRUE))
    #     plotly::ggplotly(p)
    #   })
    # }
    
  }
}
```


<p>&nbsp;</p>

```{r }
idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
idMta <- idMta[length(idMta)]
pred <- result$predictions
pred <- pred[pred$analysisId == idMta,]
traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
traitsInPreds <- unique(pred$trait)
```

`r if (sum(grepl("envIndex",traitsInPreds))>0) {"### Trait by trait-sensitivity plots\n
The following plots allow the user to select individual not only based on the scale of the trait but also by the sensitivity of the germplasm to the environmental covariates. These plots are only constructed if the MET model included the GxE in the modeling.\n"}`

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  result$status <- result$status#[1:6,]
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
  # traits <- unique(pred$trait)
  traitsInPreds <- unique(pred$trait)
  covariates <- unique(result$metadata$weather$trait)
  modelUsed <- result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$parameter == "randomFormula"),"value"]
  isRRBLUP <- ifelse(length(grep("QTL",modelUsed)) > 0, TRUE, FALSE)
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    if (sum(grepl("envIndex",traitsInPreds))>0){
      selectInput(ns("traitMta3"),
                  label = "",
                  choices = traits
      )
    }
  }
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if (sum(grepl("envIndex",traitsInPreds))>0){
    
    if("params" %in% ls()){ # we will download the document
      
      cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
      
      for(iTrait in traits){ # iTrait="Yield_Mg_ha"
        cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
        
        temp.pred.box <- pred[pred$trait== ifelse(isRRBLUP, paste0(iTrait,"_QTL"), iTrait),]
        # for each possible environmental covariate iCovariate = covariates[1]
        for(iCovariate in covariates){ 
          stabilityTrait <- ifelse(isRRBLUP, paste0(iTrait,"_QTL", iCovariate), paste0(iTrait,"-", iCovariate) ) # paste0(ifelse(isRRBLUP, paste0(iTrait,"_QTL"), iTrait),"-",iCovariate)
          if(stabilityTrait %in% traitsInPreds){ # if the user modeled that existing covariate in the GxE
            subPred <- pred[which(pred[,"trait"] %in% c(ifelse(isRRBLUP, paste0(iTrait,"_QTL"), iTrait), stabilityTrait)),]
            wide <- reshape(subPred[,c("trait","designation","predictedValue")], 
                            direction = "wide", idvar = "designation",
                            timevar = "trait", v.names = "predictedValue", sep= "_")
            colnames(wide)[2:3] <- c("trait1","trait2")
            p <- ggplot(wide, aes(x=trait2, y=trait1, text=designation)) + 
              geom_point(size=2) + ylab(iTrait) + xlab(stabilityTrait) 
          }
        }
        if(length(unique(temp.pred.box$designation)) > 200){ # go fixed format
          print(p)
        }else{ # go dynamic
          print(htmltools::tagList(plotly::ggplotly(p)))
        }
      }
      
    }else{ # render in screen
      
      if(length(unique(pred$designation)) > 200){ # go fixed format
        
        shiny::renderPlot({ # regular ggplot
          
          for(iCovariate in covariates){ 
            stabilityTrait <- ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL", iCovariate), paste0(input$traitMta3,"-", iCovariate) ) # # paste0(input$traitMta3,"-",iCovariate)
            if(stabilityTrait %in% traitsInPreds){ # if the user modeled that existing covariate in the GxE
              subPred <- pred[which(pred[,"trait"] %in% c(ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL"), input$traitMta3), stabilityTrait)),]
              wide <- reshape(subPred[,c("trait","designation","predictedValue")], 
                              direction = "wide", idvar = "designation",
                              timevar = "trait", v.names = "predictedValue", sep= "_")
              colnames(wide)[2:3] <- c("trait1","trait2")
              p <- ggplot(wide, aes(x=trait2, y=trait1, text=designation)) + 
                geom_point(size=2) + ylab(input$traitMta3) + xlab(stabilityTrait) 
            }
          }
          p
          
        })
      }else{ # go dynamic
        plotly::renderPlotly({
          
          for(iCovariate in covariates){ 
            stabilityTrait <- ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL", iCovariate), paste0(input$traitMta3,"-", iCovariate) ) # paste0(input$traitMta3,"-",iCovariate)
            if(stabilityTrait %in% traitsInPreds){ # if the user modeled that existing covariate in the GxE
              subPred <- pred[which(pred[,"trait"] %in% c(ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL"), input$traitMta3), stabilityTrait)),]
              wide <- reshape(subPred[,c("trait","designation","predictedValue")], 
                              direction = "wide", idvar = "designation",
                              timevar = "trait", v.names = "predictedValue", sep= "_")
              colnames(wide)[2:3] <- c("trait1","trait2")
              p <- ggplot(wide, aes(x=trait2, y=trait1, text=designation)) + 
                geom_point(size=2) + ylab(input$traitMta3) + xlab(stabilityTrait) 
            }
          }
          plotly::ggplotly(p)
        })
      }
    }
  }
}
```


<p>&nbsp;</p>

### Genetic correlations between traits

The following graph allows to see the genetic correlations among traits using across environment estimates.

<p>&nbsp;</p>

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred.mta <- result$predictions
  pred.mta <- pred.mta[pred.mta$analysisId == idMta,]
  predictions.gcorrT <- subset(pred.mta, select = c(trait,designation,environment,predictedValue))
  # nTraits <- unique(predictions.gcorrE[,"trait"])
  # addTextInPlots <- ifelse(length(nTraits) > 40, FALSE, TRUE)
  
  wide <- stats::reshape(predictions.gcorrT,
                         direction = "wide", idvar = "designation",
                         timevar = "trait", v.names = "predictedValue", sep= "")
  colnames(wide) <- gsub("predictedValue","",colnames(wide))
  wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
  corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
  mydata4 <- cgiarBase::matToTab(corr)
  if(nrow(corr) > 1){
    if("params" %in% ls()){ # we will download the document
      
      # p.cor.pred.traits <- corPlotPredictions(predictions.gcorrT, traitPredictionsCorrelation=NULL, unitOfCorrelation="designation", correlatedAcross="trait",
      #                                         valueForCorrelation="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots, 
      #                                         checkboxAxis= addTextInPlots)
      # print(htmltools::tagList(plotly::ggplotly(p.cor.pred.traits)))
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white",
                                      midpoint = 0, limit = c(-1,1), space = "Lab",
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() + 
        ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black"), 
                       axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1))
      if(nrow(corr) < 20){ # if user wants to fill cell values
        p <- p + ggplot2::geom_text(ggplot2::aes(label = round(Freq,2) ), color = "black", size = 4)
      }
      print(p)
      
    }else{
      
      # plotly::renderPlotly({
      shiny::renderPlot({
        # p.cor.pred.traits <- corPlotPredictions(predictions.gcorrT, traitPredictionsCorrelation=NULL, unitOfCorrelation="designation", correlatedAcross="trait",
        #                                         valueForCorrelation="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots, 
        #                                         checkboxAxis= addTextInPlots)
        # plotly::layout(p.cor.pred.traits,font=font.plot_ly)
        p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
          ggplot2::geom_tile(color = "white")+
          ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white",
                                        midpoint = 0, limit = c(-1,1), space = "Lab",
                                        name="Pearson\nCorrelation") +
          ggplot2::theme_minimal()+
          ggplot2::ylab("") + ggplot2::xlab("") +
          ggplot2::coord_fixed() + 
          ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black"), 
                         axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1))
        if(nrow(corr) < 20){ # if user wants to fill cell values
          p <- p + ggplot2::geom_text(ggplot2::aes(label = round(Freq,2) ), color = "black", size = 4)
        }
        print(p)
      })
      
    }
  }else{
    cat("Only one trait fitted. Skipping correlation plot.")
  }
  
}
```

<p>&nbsp;</p>

### Predictions 

The following table allows to check the trait predictions in wide format together with the QTL profile in case those are available.

<p>&nbsp;</p>

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred.mta <- result$predictions
  pred.mta <- pred.mta[pred.mta$analysisId == idMta,]
  traits <- unique(pred.mta$trait)
  pred.mta <- subset(pred.mta, select = c(trait,designation,environment,predictedValue))
  pred.mta.wide <- reshape(
    data=pred.mta, 
    timevar = c("trait"), 
    idvar = c("environment","designation"), 
    direction="wide"
  )
  names(pred.mta.wide) <- c("designation","environment",traits)
  
  if(!is.null(result$data$qtl)  ){ # there's QTL information
    if(nrow(result$data$qtl)>0){
      qtls <- result$data$qtl
      colnames(qtls) <- cgiarBase::replaceValues(Source = colnames(qtls), Search = result$metadata$qtl$value , Replace = result$metadata$qtl$parameter)
      pred.mta.wide <- merge(pred.mta.wide, qtls, by="designation", all.x = TRUE)
    }
  }
  
  if("params" %in% ls()){ # we will download the document
    printTable(pred.mta.wide)
  }else{
    DT::renderDT({DT::formatRound(DT::datatable(
      pred.mta.wide,
      extensions = 'Buttons',
      rownames = FALSE,
      class = 'cell-border',
      options = list(
        dom = 'Blfrtip',
        scrollY = "400px",
        scrollX = "400px",
        buttons = c('copy','csv','excel','pdf','print'),
        paging = F)
    ),traits)
    })
  }
  
}

```


### References of methods used

Finlay, K. W., & Wilkinson, G. N. (1963). The analysis of adaptation in a plant-breeding programme. Australian journal of agricultural research, 14(6), 742-754.

Henderson Jr, C. R. (1982). Analysis of covariance in the mixed model: higher-level, nonhomogeneous, and random regressions. Biometrics, 623-640.

Odegard, J., Indahl, U., Stranden, I., & Meuwissen, T. H. (2018). Large-scale genomic prediction using singular value decomposition of the genotype matrix. Genetics Selection Evolution, 50(1), 1-12.

R Core Team (2021). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

Boer M, van Rossum B (2022). LMMsolver: Linear Mixed Model Solver. R package version 1.0.4.9000.

Covarrubias-Pazaran G. 2016. Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6):1-15.

<p>&nbsp;</p>


