---
title: "MTA Report"
author: ""
date: "2023-11-03"
output: html_document
params:
  toDownload: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, error = FALSE)
font.plot_ly <- list(family="Courier New, monospace", size=9)
```

```{r printfxn, include=FALSE}
# functions ####
# for printing tables (data.frames) - DT::datatable()
printTable <- function(DT, pageLength = 7, 
                       numericColNames = NULL, numRound = 3, ...) {
  
  DT <- data.frame(lapply(X = DT, 
                          FUN = function(x) {
                            if(is.numeric(x)){
                              round(x, numRound)
                            } else {
                              x
                            }
                          }))
  
  table <- DT::datatable(data = DT, 
                         filter = "top", 
                         options = list(autoWidth = TRUE, 
                                        dom = 'l<<t>pB>', 
                                        buttons = c('copy', 'excel'),
                                        pageLength = pageLength,
                                        searchHighlight = TRUE,
                                        lengthMenu = c(7, 14, 21, 28, 35)),
                         extensions = 'Buttons',
                         rownames = FALSE,
                         ...)
  if (length(numericColNames) > 0){
    table <- table %>% formatRound(columns = numericColNames,
                                   digits = numRound)
  }
  
  table
}
```

```{r plot_init, include = FALSE}
# Init Step to make sure that the dependencies are loaded
# was done to enable proper printing of the tab header and the graphs within the for loop below using print(htmltools::tagList(ggplotly(...)))
library(ggplot2)
htmltools::tagList(plotly::ggplotly(ggplot2::ggplot()))
htmltools::tagList(printTable(mtcars))
# Get the current figure size in pixels:
get_w <- function() {
  with(knitr::opts_current$get(c("fig.width", "dpi", "fig.retina")),
       fig.width*dpi/fig.retina)
}

get_h <- function() {
  with(knitr::opts_current$get(c("fig.height", "dpi", "fig.retina")),
       fig.height*dpi/fig.retina)
}

```

```{r }

suppressWarnings(tryCatch({
  if(file.exists("./outputs/result.RData")){
    load("./outputs/resultMta.RData")
  }else{
    load("resultMta.RData")
  }
}, error = function(e) {
  # NULL
}))

if (is.null(result)){
  # invisible(NULL)
} else {
  # result$status <- result$status[1:6,]
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
}
```

### By environment merit distribution

The following boxplot allows to see the distribution of predicted values (y-axis) in the different environments for each **trait**.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitMta"), 
                label = "", 
                choices = traits
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  idSta <- result$modeling[result$modeling$analysisId == idMta & result$modeling$trait == "inputObject","value"]
  
  pred.sta <- result$predictions
  pred.sta <- pred.sta[pred.sta$analysisId == idSta,]
  pred.sta.boxplot <- subset(pred.sta, select = c(trait,designation,environment,predictedValue))
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("### Distribution by environment  {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      temp.pred.box <- pred.sta.boxplot[pred.sta.boxplot$trait== iTrait,]
      
      p <- plotly::plot_ly( data = temp.pred.box, y = ~predictedValue, x = ~environment,
                            type = "box", color = ~environment
      ) %>%  plotly::layout(font=font.plot_ly, xaxis=list( title=""), yaxis=list( title="Trait value")  )
      
      if(length(unique(temp.pred.box$designation)) > 200){ # go fixed format
        print(p)
      }else{ # go dynamic
        print(htmltools::tagList(plotly::ggplotly(p)))
      }
      
    }
    
  } else{
    
    if(length(unique(pred$designation)) > 200){ # go fixed format
      shiny::renderPlot({
        temp.pred.box <- pred.sta.boxplot[pred.sta.boxplot$trait==input$traitMta,]
        p <- temp.pred.box %>%
          ggplot() +
          aes(x=environment, y=predictedValue, fill = environment) +
          geom_boxplot() +
          labs(x = "", y = "Trait value") +
          scale_fill_discrete(name = "") +
          theme_minimal() +
          theme(axis.text.x = element_blank(),
                axis.ticks.x = element_blank(),
                text = element_text(family = "Courier New, monospace", size=9))
        p
      })
    } else { # go dynamic
      plotly::renderPlotly({
        temp.pred.box <- pred.sta.boxplot[pred.sta.boxplot$trait==input$traitMta,]
        p <- plotly::plot_ly( data = temp.pred.box, y = ~predictedValue,
                              x = ~environment,  type = "box", color = ~environment
        ) %>%  plotly::layout( font=font.plot_ly,
                               xaxis=list( title=""), yaxis=list( title="Trait value") )
        p
      })
      
    }
  }
  
}
```

### Across-environment merit estimates

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  result$status <- result$status#[1:6,]
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(pred$trait)
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitMta2"),
                label = "",
                choices = traits
    )
  }
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      temp.pred.box <- pred[pred$trait== iTrait,]
      
      p <- ggplot2::ggplot(
        data = temp.pred.box, 
        mapping = ggplot2::aes(
          x = reorder(designation, -predictedValue),
          y = predictedValue,
          col = entryType,
          text = paste(
            paste0('<br>', "designation: ", designation),
            paste0('<br>', "entry type: ", entryType),
            paste0('<br>', "predicted value: ", round(predictedValue, 4)),
            paste0('<br>', "standard error: ", round(stdError, 4)),
            # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ", 
            #        round(predictedValue + CI, 2), ")")))) +
            paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ", 
                   round(predictedValue + stdError, 4), ")")))) +
        ggplot2::theme_classic() +  ggplot2::geom_point() +
        ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                            ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                               width = 0.10) +
        ggplot2::labs(title = "across", x = "designation", y = "predicted value", col = "entry type") +
        ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7))
      if(length(unique(temp.pred.box$designation)) > 200){ # go fixed format
        print(p)
      }else{ # go dynamic
        print(htmltools::tagList(plotly::ggplotly(p)))
      }
    }
    
  }else{
    
    if(length(unique(pred$designation)) > 200){ # go fixed format
      
      shiny::renderPlot({
        
        temp.pred.box <- pred[pred$trait== input$traitMta2,]
        p <- ggplot2::ggplot(
          data = temp.pred.box,
          mapping = ggplot2::aes(
            x = reorder(designation, -predictedValue),
            y = predictedValue,
            col = entryType,
            text = paste(
              paste0('<br>', "designation: ", designation),
              paste0('<br>', "entry type: ", entryType),
              paste0('<br>', "predicted value: ", round(predictedValue, 4)),
              paste0('<br>', "standard error: ", round(stdError, 4)),
              # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ",
              #        round(predictedValue + CI, 2), ")")))) +
              paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ",
                     round(predictedValue + stdError, 4), ")")))) +
          ggplot2::theme_classic() +  ggplot2::geom_point() +
          ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                              ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                                 width = 0.10) +
          ggplot2::labs(title = "across", x = "designation", y = "predicted value", col = "entry type") +
          ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7))
        p
        
      })
    }else{ # go dynamic
      plotly::renderPlotly({
        
        temp.pred.box <- pred[pred$trait== input$traitMta2,]
        p <- ggplot2::ggplot(
          data = temp.pred.box,
          mapping = ggplot2::aes(
            x = reorder(designation, -predictedValue),
            y = predictedValue,
            col = entryType,
            text = paste(
              paste0('<br>', "designation: ", designation),
              paste0('<br>', "entry type: ", entryType),
              paste0('<br>', "predicted value: ", round(predictedValue, 4)),
              paste0('<br>', "standard error: ", round(stdError, 4)),
              # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ",
              #        round(predictedValue + CI, 2), ")")))) +
              paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ",
                     round(predictedValue + stdError, 4), ")")))) +
          ggplot2::theme_classic() +  ggplot2::geom_point() +
          ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                              ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                                 width = 0.10) +
          ggplot2::labs(title = "across", x = "designation", y = "predicted value", col = "entry type") +
          ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7))
        plotly::ggplotly(p)
      })
    }
    
  }
}
```


<p>&nbsp;</p>

```{r }
idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
idMta <- idMta[length(idMta)]
pred <- result$predictions
pred <- pred[pred$analysisId == idMta,]
traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
traitsInPreds <- unique(pred$trait)
```

`r if (sum(grepl("envIndex",traitsInPreds))>0) {"### Trait by trait-sensitivity plots\n
The following plots allow the user to select individual not only based on the scale of the trait but also by the sensitivity of the germplasm to the environmental covariates. These plots are only constructed if the MET model included the GxE in the modeling.\n"}`

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  result$status <- result$status#[1:6,]
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
  # traits <- unique(pred$trait)
  traitsInPreds <- unique(pred$trait)
  covariates <- unique(result$metadata$weather$trait)
  modelUsed <- result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$parameter == "randomFormula"),"value"]
  isRRBLUP <- ifelse(length(grep("QTL",modelUsed)) > 0, TRUE, FALSE)
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    if (sum(grepl("envIndex",traitsInPreds))>0){
      selectInput(ns("traitMta3"),
                  label = "",
                  choices = traits
      )
    }
  }
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if (sum(grepl("envIndex",traitsInPreds))>0){
    
    if("params" %in% ls()){ # we will download the document
      
      cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
      
      for(iTrait in traits){ # iTrait="Yield_Mg_ha"
        cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
        
        temp.pred.box <- pred[pred$trait== ifelse(isRRBLUP, paste0(iTrait,"_QTL"), iTrait),]
        # for each possible environmental covariate iCovariate = covariates[1]
        for(iCovariate in covariates){ 
          stabilityTrait <- ifelse(isRRBLUP, paste0(iTrait,"_QTL", iCovariate), paste0(iTrait,"-", iCovariate) ) # paste0(ifelse(isRRBLUP, paste0(iTrait,"_QTL"), iTrait),"-",iCovariate)
          if(stabilityTrait %in% traitsInPreds){ # if the user modeled that existing covariate in the GxE
            subPred <- pred[which(pred[,"trait"] %in% c(ifelse(isRRBLUP, paste0(iTrait,"_QTL"), iTrait), stabilityTrait)),]
            wide <- reshape(subPred[,c("trait","designation","predictedValue")], 
                            direction = "wide", idvar = "designation",
                            timevar = "trait", v.names = "predictedValue", sep= "_")
            colnames(wide)[2:3] <- c("trait1","trait2")
            p <- ggplot(wide, aes(x=trait2, y=trait1, text=designation)) + 
              geom_point(size=2) + ylab(iTrait) + xlab(stabilityTrait) 
          }
        }
        if(length(unique(temp.pred.box$designation)) > 200){ # go fixed format
          print(p)
        }else{ # go dynamic
          print(htmltools::tagList(plotly::ggplotly(p)))
        }
      }
      
    }else{ # render in screen
      
      if(length(unique(pred$designation)) > 200){ # go fixed format
        
        shiny::renderPlot({ # regular ggplot
          
          for(iCovariate in covariates){ 
            stabilityTrait <- ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL", iCovariate), paste0(input$traitMta3,"-", iCovariate) ) # # paste0(input$traitMta3,"-",iCovariate)
            if(stabilityTrait %in% traitsInPreds){ # if the user modeled that existing covariate in the GxE
              subPred <- pred[which(pred[,"trait"] %in% c(ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL"), input$traitMta3), stabilityTrait)),]
              wide <- reshape(subPred[,c("trait","designation","predictedValue")], 
                              direction = "wide", idvar = "designation",
                              timevar = "trait", v.names = "predictedValue", sep= "_")
              colnames(wide)[2:3] <- c("trait1","trait2")
              p <- ggplot(wide, aes(x=trait2, y=trait1, text=designation)) + 
                geom_point(size=2) + ylab(input$traitMta3) + xlab(stabilityTrait) 
            }
          }
          p
          
        })
      }else{ # go dynamic
        plotly::renderPlotly({
          
          for(iCovariate in covariates){ 
            stabilityTrait <- ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL", iCovariate), paste0(input$traitMta3,"-", iCovariate) ) # paste0(input$traitMta3,"-",iCovariate)
            if(stabilityTrait %in% traitsInPreds){ # if the user modeled that existing covariate in the GxE
              subPred <- pred[which(pred[,"trait"] %in% c(ifelse(isRRBLUP, paste0(input$traitMta3,"_QTL"), input$traitMta3), stabilityTrait)),]
              wide <- reshape(subPred[,c("trait","designation","predictedValue")], 
                              direction = "wide", idvar = "designation",
                              timevar = "trait", v.names = "predictedValue", sep= "_")
              colnames(wide)[2:3] <- c("trait1","trait2")
              p <- ggplot(wide, aes(x=trait2, y=trait1, text=designation)) + 
                geom_point(size=2) + ylab(input$traitMta3) + xlab(stabilityTrait) 
            }
          }
          plotly::ggplotly(p)
        })
      }
    }
  }
}
```


<p>&nbsp;</p>

### Genetic correlations between environments

The following graph allows to see the genetic correlations among the different environment one **trait** at a time. If the user modeled GxE, this matrix is calculated as the correlation between the environment-specific estimates for individuals. If a pure main-effect model is specified this matrix is calculated as the correlation between the single-trial analysis estimates.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"])# unique(pred$trait)
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitPredictionsCorrelation"),
                label = "",
                choices = traits
    )
  }
  
}

```


```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  idSta <- result$modeling[result$modeling$analysisId == idMta & result$modeling$trait == "inputObject","value"]
  pred.sta <- result$predictions
  pred.sta <- pred.sta[pred.sta$analysisId == idSta,]
  # traits <- unique(pred.sta$trait)
  predictions.gcorrE <- subset(pred.sta, select = c(trait,designation,environment,predictedValue))
  envs <- unique(predictions.gcorrE[,"environment"])
  addTextInPlots <- ifelse(length(envs) > 30, FALSE, TRUE)
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      p.cor.pred.env <- corPlotPredictions(predictions.gcorrE, iTrait, unitOfCorrelation="designation", correlatedAcross="environment", valueForCorrelation ="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots, checkboxAxis= addTextInPlots)
      print(htmltools::tagList(plotly::ggplotly(p.cor.pred.env)))
      
    }
    
  }else{
    
    plotly::renderPlotly({
      p.cor.pred.env <- corPlotPredictions(predictions.gcorrE, input$traitPredictionsCorrelation, unitOfCorrelation="designation", correlatedAcross="environment",
                                           valueForCorrelation="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots,
                                           checkboxAxis= addTextInPlots)
      plotly::layout(p.cor.pred.env,font=font.plot_ly)
    })
    
    
  }
  
}
```

<p>&nbsp;</p>

## Genetic correlations between traits

The following graph allows to see the genetic correlations among traits using across environment estimates.

<p>&nbsp;</p>

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred.mta <- result$predictions
  pred.mta <- pred.mta[pred.mta$analysisId == idMta,]
  predictions.gcorrT <- subset(pred.mta, select = c(trait,designation,environment,predictedValue))
  nTraits <- unique(predictions.gcorrE[,"trait"])
  addTextInPlots <- ifelse(length(nTraits) > 40, FALSE, TRUE)
  if(length(nTraits) > 1){
    if("params" %in% ls()){ # we will download the document
      
      p.cor.pred.traits <- corPlotPredictions(predictions.gcorrT, traitPredictionsCorrelation=NULL, unitOfCorrelation="designation", correlatedAcross="trait",
                                              valueForCorrelation="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots, 
                                              checkboxAxis= addTextInPlots)
      print(htmltools::tagList(plotly::ggplotly(p.cor.pred.traits)))
      
    }else{
      
      plotly::renderPlotly({
        p.cor.pred.traits <- corPlotPredictions(predictions.gcorrT, traitPredictionsCorrelation=NULL, unitOfCorrelation="designation", correlatedAcross="trait",
                                                valueForCorrelation="predictedValue",checkboxCluster=TRUE, checkboxText=addTextInPlots, 
                                                checkboxAxis= addTextInPlots)
        plotly::layout(p.cor.pred.traits,font=font.plot_ly)
      })
      
    }
  }else{
    cat("Only one trait fitted. Skipping correlation plot.")
  }
  
}
```

<p>&nbsp;</p>

## Variance component proportions

The following graph allows to see the proportion of variance going to different components.

<p>&nbsp;</p>


```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  idMtaVC <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMtaVC <- idMtaVC[length(idMtaVC)]
  traitsvc <- unique(result$modeling[which(result$modeling$analysisId == idMtaVC  & result$modeling$environment == "across"),"trait"])
  covariatesvc <- unique(result$metadata$weather$trait)
  df2 <- result$metrics
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"];
  idMta <- idMta[length(idMta)]
  df2 <- df2[df2$analysisId==idMta,]
  df2 <- df2[df2$parameter %in% c("Vg","Vr","Vp"), ]
  df2$traitOriginal <-  df2$trait
  for(iCov in covariatesvc){
    df2$traitOriginal <- gsub(paste0("-",iCov),"",df2$traitOriginal)
    df2$traitOriginal <- gsub(paste0(iCov),"",df2$traitOriginal)
  }
  df2$parameterOriginal <- df2$trait
  for(iCov in traitsvc){ df2$parameterOriginal <- gsub(iCov,"",df2$parameterOriginal)}
  df2$parameterOriginal <- paste0(df2$parameter, df2$parameterOriginal)
  
  total <- aggregate(value~traitOriginal, FUN = sum, data=df2); 
  colnames(total)[2] <- "totalVar"
  df3 <- merge(df2,total, by=c("traitOriginal") )
  df3$valueProp <- df3$value/df3$totalVar
  
  if("params" %in% ls()){ # we will download the document
    cat("\n\n###  {.tabset .tabset-pills}       \n\n")
    # for (j in 1:length(traitsvc)){
    #   cat("\n\n####", traitsvc[j], "{.tabset .tabset-pills}       \n\n")
    # df4 <- df3[df3$traitOriginal == traitsvc[j],]
    p <- ggplot2::ggplot(data=df3, ggplot2::aes(x=traitOriginal, y=valueProp, fill=parameterOriginal)) +
      ggplot2::geom_bar(stat="identity") +
      ggplot2::xlab("Traits") + ggplot2::ylab("Proportion of variance") +
      scale_fill_brewer(palette="Accent") +
      ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45)) +
      ggplot2::geom_hline(yintercept = seq(0.25,0.75,0.25), linetype = 3, colour = 'red')
    print(p)
    # cat("\n")
    # }
    cat("\n")
  }else{
    
    shiny::renderPlot({
      # df3 <- df3[df3$traitOriginal == input$traitPredictionsVC,]
      ggplot2::ggplot(data=df3, ggplot2::aes(x=traitOriginal, y=valueProp, fill=parameterOriginal)) +
        ggplot2::geom_bar(stat="identity") +
        ggplot2::xlab("Traits") + ggplot2::ylab("Proportion of variance") +
        scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45)) +
        ggplot2::geom_hline(yintercept = seq(0.25,0.75,0.25), linetype = 3, colour = 'red')
    })
  }
  
}
```

<p>&nbsp;</p>

## Biplot by trait

The following graph allows to see the performance of the genotypes over the enevironments for each **trait**.

<p>&nbsp;</p>

```{r}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred.mta <- result$predictions
  pred.mta <- pred.mta[pred.mta$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred.mta$trait)
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitBiplot"),
                label = "",
                choices = traits
    )
  }
}

```

```{r, results='asis'}

if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  idSta <- result$modeling[result$modeling$analysisId == idMta & result$modeling$trait == "inputObject","value"]
  pred.sta <- result$predictions
  pred.sta <- pred.sta[pred.sta$analysisId == idSta,]
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      pred.mta.biplot <- reshape(pred.sta[which(pred.sta$trait == iTrait),c("designation","environment","predictedValue")], 
                                 direction = "wide", idvar = "designation", timevar = "environment")
      
      rownames(pred.mta.biplot) <- pred.mta.biplot[,"designation"]
      pred.mta.biplot <- pred.mta.biplot[,-1]
      names(pred.mta.biplot) <- gsub("predictedValue.","",names(pred.mta.biplot))
      
      # keep only 
      missing <- apply(pred.mta.biplot,1, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[which(missing < 0.8),]
      missing <- apply(pred.mta.biplot,2, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[,which(missing < 0.8)]
      pred.mta.biplot <- apply(pred.mta.biplot,2, sommer::imputev)
      # pred.mta.biplot <- na.omit(pred.mta.biplot[,2:min(c(ncol(pred.mta.biplot),5))])
      prin_comp <- prcomp(pred.mta.biplot, rank = 2)
      components <- prin_comp[["x"]]
      components <- data.frame(components)
      components$PC2 <- -components$PC2
      
      explained_variance <- summary(prin_comp)[["sdev"]]
      explained_variance <- explained_variance[1:2]
      comp <- prin_comp[["rotation"]]
      comp[,'PC2'] <- - comp[,'PC2']
      loadings <- comp
      for (i in seq(explained_variance) ){
        loadings[,i] <- comp[,i] * explained_variance[i]
      }
      p.mta.biplot <- plotly::plot_ly (type = 'scatter', mode = 'markers')
      p.mta.biplot <- plotly::add_trace(p.mta.biplot, 
                                        x=components$PC1,
                                        y=components$PC2,
                                        text=rownames(components),
                                        marker=list(color="blue"),
                                        hoverinfo='text',
                                        showlegend=FALSE
      )
      for (i in 1:ncol(pred.mta.biplot)){
        p.mta.biplot <- p.mta.biplot %>%
          plotly::add_segments(x = 0, xend = loadings[i, 1], y = 0, yend = loadings[i, 2], line = list(color = 'red'),inherit = FALSE, showlegend = FALSE)
        if(ncol(pred.mta.biplot) < 20){
          p.mta.biplot <- p.mta.biplot %>%
            plotly::add_annotations(x=loadings[i, 1], y=loadings[i, 2], ax = 0, ay = 0,text = rownames(loadings)[i], xanchor = 'center', yanchor= 'bottom')
        }
      }
      print(htmltools::tagList(plotly::ggplotly(p.mta.biplot)))
      
    }
    
  }else{
    
    plotly::renderPlotly({
      pred.mta.biplot <- reshape(pred.sta[which(pred.sta$trait == input$traitBiplot),c("designation","environment","predictedValue")], 
                                 direction = "wide", idvar = "designation", timevar = "environment")
      
      rownames(pred.mta.biplot) <- pred.mta.biplot[,"designation"]
      pred.mta.biplot <- pred.mta.biplot[,-1]
      names(pred.mta.biplot) <- gsub("predictedValue.","",names(pred.mta.biplot))
      
      # keep only 
      missing <- apply(pred.mta.biplot,1, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[which(missing < 0.8),]
      missing <- apply(pred.mta.biplot,2, function(x){length(which(is.na(x)))/length(x)})
      pred.mta.biplot <- pred.mta.biplot[,which(missing < 0.8)]
      pred.mta.biplot <- apply(pred.mta.biplot,2, sommer::imputev)
      # pred.mta.biplot <- na.omit(pred.mta.biplot[,2:min(c(ncol(pred.mta.biplot),5))])
      
      prin_comp <- prcomp(pred.mta.biplot, rank = 2)
      components <- prin_comp[["x"]]
      components <- data.frame(components)
      components$PC2 <- -components$PC2
      
      explained_variance <- summary(prin_comp)[["sdev"]]
      explained_variance <- explained_variance[1:2]
      comp <- prin_comp[["rotation"]]
      comp[,'PC2'] <- - comp[,'PC2']
      loadings <- comp
      for (i in seq(explained_variance) ){
        loadings[,i] <- comp[,i] * explained_variance[i]
      }
      
      p.mta.biplot <- plotly::plot_ly (type = 'scatter', mode = 'markers')
      p.mta.biplot <- plotly::add_trace(p.mta.biplot, 
                                        x=components$PC1,
                                        y=components$PC2,
                                        text=rownames(components),
                                        marker=list(color="blue"),
                                        hoverinfo='text',
                                        showlegend=FALSE
      )
      
      
      for (i in 1:ncol(pred.mta.biplot)){
        p.mta.biplot <- p.mta.biplot %>%
          plotly::add_segments(x = 0, xend = loadings[i, 1], y = 0, yend = loadings[i, 2], line = list(color = 'red'),inherit = FALSE, showlegend = FALSE)
        if(ncol(pred.mta.biplot) < 20){
          p.mta.biplot <- p.mta.biplot %>%
            plotly::add_annotations(x=loadings[i, 1], y=loadings[i, 2], ax = 0, ay = 0,text = rownames(loadings)[i], xanchor = 'center', yanchor= 'bottom')
        }
      }
      plotly::layout(p.mta.biplot,font=font.plot_ly)
    })
    
  }
  
}

```


<p>&nbsp;</p>

### Predictions 

The following table allows to check the trait predictions in wide format together with the QTL profile in case those are available.

<p>&nbsp;</p>

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  idMta <- result$status[which(result$status$module == "mta"),"analysisId"]
  idMta <- idMta[length(idMta)]
  pred.mta <- result$predictions
  pred.mta <- pred.mta[pred.mta$analysisId == idMta,]
  traits <- unique(pred.mta$trait)
  pred.mta <- subset(pred.mta, select = c(trait,designation,environment,predictedValue))
  pred.mta.wide <- reshape(
    data=pred.mta, 
    timevar = c("trait"), 
    idvar = c("environment","designation"), 
    direction="wide"
  )
  names(pred.mta.wide) <- c("designation","environment",traits)
  
  if(!is.null(result$data$qtl)  ){ # there's QTL information
    if(nrow(result$data$qtl)>0){
      qtls <- result$data$qtl
      colnames(qtls) <- cgiarBase::replaceValues(Source = colnames(qtls), Search = result$metadata$qtl$value , Replace = result$metadata$qtl$parameter)
      pred.mta.wide <- merge(pred.mta.wide, qtls, by="designation", all.x = TRUE)
    }
  }
  
  if("params" %in% ls()){ # we will download the document
    printTable(pred.mta.wide)
  }else{
    DT::renderDT({DT::formatRound(DT::datatable(
      pred.mta.wide,
      extensions = 'Buttons',
      rownames = FALSE,
      class = 'cell-border',
      options = list(
        dom = 'Blfrtip',
        scrollY = "400px",
        scrollX = "400px",
        buttons = c('copy','csv','excel','pdf','print'),
        paging = F)
    ),traits)
    })
  }
  
}

```




