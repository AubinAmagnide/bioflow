---
title: "Accelerated Breeding Initiative Dashboard"
author: ""
date: "2023-11-03"
output: html_document
params:
 toDownload: FALSE
---

```{r setup, include=FALSE}
# knitr R markdown chunk options
knitr::opts_chunk$set(dependson = knitr::all_labels(),
                      echo = FALSE,
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      comment = NA,
                      out.width = "100%",
                      error = TRUE)
options(knitr.kable.NA = '')
# loading necessary R packages ####
## data manipulation
# library(dplyr)    # %>%, data cleaning functions
library(magrittr) # coerce col to factors or numeric
## outputs - graphs, tables
library(ggplot2)  # ggplot(), etc.
library(plotly)  # ggplot(), etc.
library(DT)       # datatable()
library(knitr)    # kable
library(data.table)
library(shiny)
```

```{r printfxn, include=FALSE}

# functions ####
# for printing tables (data.frames) - DT::datatable()
printTable <- function(DT, pageLength = 7, 
                       numericColNames = NULL, numRound = 3, ...) {
  
  DT <- data.frame(lapply(X = DT, 
                          FUN = function(x) {
                            if(is.numeric(x)){
                              round(x, numRound)
                            } else {
                              x
                            }
                          }))
  
  table <- DT::datatable(data = DT, 
                         filter = "top", 
                         options = list(autoWidth = TRUE, 
                                        dom = 'l<<t>pB>', 
                                        buttons = c('copy', 'excel'),
                                        pageLength = pageLength,
                                        searchHighlight = TRUE,
                                        lengthMenu = c(7, 14, 21, 28, 35)),
                         extensions = 'Buttons',
                         rownames = FALSE,
                         ...)
  if (length(numericColNames) > 0){
    table <- table %>% formatRound(columns = numericColNames,
                                   digits = numRound)
  }
  
  table
}
```

```{r, include=FALSE}
# Init Step to make sure that the dependencies are loaded
htmltools::tagList(printTable(mtcars))
htmltools::tagList(ggplotly(ggplot()))
# Get the current figure size in pixels:
get_w <- function() {
  with(knitr::opts_current$get(c("fig.width", "dpi", "fig.retina")),
       fig.width*dpi/fig.retina)
}

get_h <- function() {
  with(knitr::opts_current$get(c("fig.height", "dpi", "fig.retina")),
       fig.height*dpi/fig.retina)
}
```

```{r, results='asis'}
suppressWarnings(tryCatch({
  if(file.exists("./outputs/resultAbi.RData")){
    load("./outputs/resultAbi.RData")
  }else{
    load("resultAbi.RData")
  }
}, error = function(e) {
  # NULL
}))

if (is.null(result)){
  # invisible(NULL)
} else {
  ###############################################################################
  ## This tell us where to pick the IDs for the dashboard
  idAbi <- result$status[which(result$status$module == "abiDash"),"analysisId"];
  idAbi <- idAbi[length(idAbi)]
  modelingAbi <- result$modeling[result$modeling$analysisId == idAbi, ]
  ###############################################################################
  
}
```

### Data use

The following visualization shows which data types was used for this pipeline. It allows to see whether the data has been QA and the summary values for the different data types.

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  
  idMta <- modelingAbi[modelingAbi$parameter == "mta", "value"]
  
  mtaTraits <- setdiff( unique(result$modeling[result$modeling$analysisId == idMta,"trait"]), "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    shiny::selectInput(ns("traitMta"), 
                       label = "Trait:", 
                       multiple = FALSE,
                       choices = mtaTraits, 
    )
  }
  
}

```

<p>&nbsp;</p>

```{r, results='asis'}


if (is.null(result)){
  # invisible(NULL)
} else {
  ###############################################################################
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in mtaTraits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      object <- result
      if(!is.null(object$predictions)){
        phenoNames <- na.omit(unique(object$predictions[which(object$predictions$analysisId == idMta  &  object$predictions$trait == iTrait),"designation"]))
      }else{ phenoNames <- character() }
      
      if(!is.null(object$data$geno)){
        genoNames <- rownames(object$data$geno)
      }else{ genoNames <- character() }
      
      if(!is.null(object$data$pedigree)){
        metaPed <- object$metadata$pedigree
        pedCols <- metaPed[which(metaPed$parameter %in% c("designation","mother","father")), "value"]
        pedCols <- setdiff(pedCols,"")
        pedNames <- na.omit(unique(unlist(as.vector(object$data$pedigree[,pedCols, drop=FALSE]))))
      }else{ pedNames <- character() }
      
      if(!is.null(object$data$qtl)){
        metaQtl <- object$metadata$qtl
        qtlCols <- metaQtl[which(metaQtl$parameter %in% c("designation")), "value"]
        qtlCols <- setdiff(qtlCols,"")
        qtlNames <- na.omit(unique(object$data$qtl[,qtlCols]))
      }else{ qtlNames <- character() }
      
      splitAggregate <- list(phenoNames, genoNames, pedNames, qtlNames)
      names(splitAggregate) <- c("With-Phenotype","With-Genotype","With-Pedigree","With-QTL")
      
      nagm <- matrix(0,length(splitAggregate),length(splitAggregate)); rownames(nagm) <- colnames(nagm) <- names(splitAggregate) # prefilled matrix
      for(i in 1:length(splitAggregate)){ # fill the matrix of intersection of individuals between pair of environments
        for(j in 1:i){
          nagm[i,j] <- length(intersect(splitAggregate[[i]],splitAggregate[[j]]))
        }
      }
      nagm[upper.tri(nagm)] <- t(nagm)[upper.tri(nagm)] # fill the upper triangular
      mydata4 <- cgiarBase::matToTab(nagm) # matrix to a dataframe for plot
      maxVal <- max(nagm, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
      midval <- (max(nagm, na.rm = TRUE) - min(nagm, na.rm = TRUE) )/2
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "firebrick", high = "#038542", mid = "gold",
                                      midpoint = midval, limit = c(0,maxVal), space = "Lab",
                                      name="Connectivity (data types)") +
        ggplot2::theme_minimal()+
        ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 3 ) +
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1,  hjust = 1, face = "bold"))+
        ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1,  hjust = 1, face = "bold")) +
        ggplot2::coord_fixed()
      print(htmltools::tagList(plotly::ggplotly(p))) # dynamic
      
    }
    
  }else{
    
    # shiny::renderPlot({ #DT::renderDT({
    plotly::renderPlotly({
      object <- result
      if(!is.null(object$predictions)){
        phenoNames <- na.omit(unique(object$predictions[which(object$predictions$analysisId == idMta  &  object$predictions$trait == input$traitMta),"designation"]))
      }else{ phenoNames <- character() }
      
      if(!is.null(object$data$geno)){
        genoNames <- rownames(object$data$geno)
      }else{ genoNames <- character() }
      
      if(!is.null(object$data$pedigree)){
        metaPed <- object$metadata$pedigree
        pedCols <- metaPed[which(metaPed$parameter %in% c("designation","mother","father")), "value"]
        pedCols <- setdiff(pedCols,"")
        pedNames <- na.omit(unique(unlist(as.vector(object$data$pedigree[,pedCols, drop=FALSE]))))
      }else{ pedNames <- character() }
      
      if(!is.null(object$data$qtl)){
        metaQtl <- object$metadata$qtl
        qtlCols <- metaQtl[which(metaQtl$parameter %in% c("designation")), "value"]
        qtlCols <- setdiff(qtlCols,"")
        qtlNames <- na.omit(unique(object$data$qtl[,qtlCols]))
      }else{ qtlNames <- character() }
      
      splitAggregate <- list(phenoNames, genoNames, pedNames, qtlNames)
      names(splitAggregate) <- c("With-Phenotype","With-Genotype","With-Pedigree","With-QTL")
      
      nagm <- matrix(0,length(splitAggregate),length(splitAggregate)); rownames(nagm) <- colnames(nagm) <- names(splitAggregate) # prefilled matrix
      for(i in 1:length(splitAggregate)){ # fill the matrix of intersection of individuals between pair of environments
        for(j in 1:i){
          nagm[i,j] <- length(intersect(splitAggregate[[i]],splitAggregate[[j]]))
        }
      }
      nagm[upper.tri(nagm)] <- t(nagm)[upper.tri(nagm)] # fill the upper triangular
      mydata4 <- cgiarBase::matToTab(nagm) # matrix to a dataframe for plot
      maxVal <- max(nagm, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
      midval <- (max(nagm, na.rm = TRUE) - min(nagm, na.rm = TRUE) )/2
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "firebrick", high = "#038542", mid = "gold",
                                      midpoint = midval, limit = c(0,maxVal), space = "Lab",
                                      name="Connectivity (data types)") +
        ggplot2::theme_minimal()+
        ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 3 ) +
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1,  hjust = 1, face = "bold"))+
        ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1,  hjust = 1, face = "bold")) +
        ggplot2::coord_fixed()
      # p # static
      plotly::ggplotly(p) # dynamic
    })
    
    
  }
  
}
```

### Base metrics

The following barplot shows the value of the different parameters calculated per trial during the single trial analysis run. The view can be modified by trait and by parameter.

Variance component proportions

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  
  idSta <- modelingAbi[modelingAbi$parameter == "sta", "value"]
  staTraits <- setdiff( unique(result$modeling[result$modeling$analysisId == idSta,"trait"]), "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    shiny::selectInput(ns("traitSta"), 
                       label = "Trait:", 
                       multiple = FALSE,
                       choices = staTraits, 
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  df2 <- result$metrics
  df2 <- df2[df2$analysisId==idSta,]
  df2 <- df2[df2$parameter %in% c("Vg","Vr"), ]
  total <- aggregate(value~environment+trait, FUN = sum, data=df2); 
  colnames(total)[3] <- "totalVar"
  df3 <- merge(df2,total, by=c("environment","trait") )
  df3$valueProp <- df3$value/df3$totalVar
  
  if("params" %in% ls()){ # we will download the document
    
    cat("\n\n###  {.tabset .tabset-pills}       \n\n")
    
    for (j in 1:length(staTraits)){
      cat("\n\n####", staTraits[j], "{.tabset .tabset-pills}       \n\n")
      df4 <- df3[df3$trait == staTraits[j],]
      p <- ggplot2::ggplot(data=df4, ggplot2::aes(x=environment, y=valueProp, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        ggplot2::xlab("Environment") + ggplot2::ylab("Proportion of variance") +
        ggplot2::scale_fill_brewer(palette="Accent") +
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1)) +
        ggplot2::theme(axis.text.x = ggplot2::element_blank())
      ggplot2::geom_hline(yintercept = seq(0.25,0.75,0.25), linetype = 3, colour = 'red')
      # print(p)
      p2 <- ggplot2::ggplot(data=df4, ggplot2::aes(x=environment, y=value, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        ggplot2::xlab("Environment") + ggplot2::ylab("Value of variance") +
        ggplot2::scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_blank())
      
      print(htmltools::tagList( plotly::subplot(plotly::ggplotly(p), plotly::ggplotly(p2), nrows=2) ) )
      
      cat("\n")
    }
    
    cat("\n")
    
  }else{
    
    # shiny::renderPlot({
    plotly::renderPlotly({
      df3 <- df3[df3$trait == input$traitSta,]
      p <- ggplot2::ggplot(data=df3, ggplot2::aes(x=environment, y=valueProp, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        ggplot2::xlab("Environment") + ggplot2::ylab("Proportion of variance") +
        scale_fill_brewer(palette="Accent") +
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1)) +
        ggplot2::theme(axis.text.x = ggplot2::element_blank())
      ggplot2::geom_hline(yintercept = seq(0.25,0.75,0.25), linetype = 3, colour = 'red')
      p2 <- ggplot2::ggplot(data=df3, ggplot2::aes(x=environment, y=value, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        ggplot2::xlab("Environment") + ggplot2::ylab("Value of variance") +
        scale_fill_brewer(palette="Accent") +
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1))
        ggplot2::theme(axis.text.x = ggplot2::element_blank())
      # gridExtra::grid.arrange(p,p2)
      ply1 <- plotly::ggplotly(p)
      ply2 <- plotly::ggplotly(p2)
      plotly::subplot(ply1, ply2, nrows=2)
    })
  }
  
}
```

Barplot for parameter values

```{r}
if (is.null(result)){
  # invisible(NULL)
} else {
  metrics <- result$metrics
  idSta <- modelingAbi[modelingAbi$parameter == "sta", "value"]
  parameters <- metrics[which(metrics$analysisId == idSta),"parameter"]
  if("params" %in% ls()){  # if user will download the report
    
  }else{
    shiny::selectInput(ns("parameterMetrics"), 
                       label = "Parameter:", 
                       multiple = FALSE,
                       selected = setdiff( unique(parameters), c("Vg","Vr") ),
                       choices = setdiff( unique(parameters), c("Vg","Vr") )
    )
  }
}
```


```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  mydata = result$metrics
  mydata <- mydata[which(mydata$analysisId %in% idSta),]
  
  if("params" %in% ls()){  # if user will download the report
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    counter <- 1
    # for(iTrait in staTraits){
    for(iParam in unique(parameters)){
      cat("\n\n####", iParam, "{.tabset .tabset-pills}       \n\n")
      
      mydata2 = mydata[which(mydata$parameter %in% iParam),]
      p <- ggplot(data=mydata2, aes(x=environment, y=value, fill=trait)) +
        ggplot2::geom_bar(stat="identity", position=position_dodge()) +
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") +
        # ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black", face="bold"), axis.text.x = ggplot2::element_text(angle = 45,hjust=1, vjust = 1), legend.position = "bottom") +
        ggplot2::labs(x="Environment", y="Parameter value")
      print(htmltools::tagList(plotly::ggplotly(p)))
      # print(p)
      cat("\n")
    }
    # }
    cat("\n")
  }else{ # display in website
    
    plotly::renderPlotly({
      # shiny::renderPlot({
      mydata2 = mydata[which(mydata$parameter %in% input$parameterMetrics),]
      p <- ggplot2::ggplot(data=mydata2, aes(x=environment, y=value, fill=trait)) +
        ggplot2::geom_bar(stat="identity", position=position_dodge()) +
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") + 
        # ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black", face="bold"),  axis.text.x = ggplot2::element_text(angle = 45,hjust=1, vjust = 1), legend.position = "bottom") +
        ggplot2::labs(x="Environment", y="Parameter value")
      # p
      plotly::ggplotly(p)
    })
    
  }
  
}
```

Correlation between environments

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- modelingAbi[modelingAbi$parameter == "sta", "value"]
  modeling <- modeling[which(modeling$analysisId == idSta),"trait"]
  modeling <- setdiff(modeling, "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    
  }else{
    shiny::selectInput(ns("traitStaCor"), 
                       label = "Trait:", 
                       multiple = FALSE,
                       selected = unique(modeling),
                       choices = unique(modeling), 
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  pred <- result$predictions
  pred <- pred[pred$analysisId == idSta, ]
  predictions.gcorrE <- subset(pred, select = c(trait,designation,environment,predictedValue))
  
  # addTextInPlots <- ifelse(length(envs) > 30, FALSE, TRUE)
  if("params" %in% ls()){ # we will download the document
    
    cat("\n\n###  {.tabset .tabset-pills}       \n\n")
    
    for(iTrait in modeling){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      predictions.gcorrE2 <- predictions.gcorrE[predictions.gcorrE$trait == iTrait, ]
      wide <- stats::reshape(predictions.gcorrE2,
                             direction = "wide", idvar = "designation",
                             timevar = "environment", v.names = "predictedValue", sep= "")
      colnames(wide) <- gsub("predictedValue","",colnames(wide))
      wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
      corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
      vv <- cgiarBase::matToTab(corr)
      p <- ggplot2::ggplot(data = vv, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white", 
                                      midpoint = 0, limit = c(-1,1), space = "Lab", 
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+ 
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 8, hjust = 1))+
        # ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 8, hjust = 1))+
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) + 
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed()
      # print(p)
      print(htmltools::tagList(plotly::ggplotly(p)))
      cat("\n")
    }
    cat("\n")
    cat("\n")
  }else{
    
    # shiny::renderPlot({
    plotly::renderPlotly({
      predictions.gcorrE2 <- predictions.gcorrE[predictions.gcorrE$trait == input$traitStaCor, ]
      
      wide <- stats::reshape(predictions.gcorrE2,
                             direction = "wide", idvar = "designation",
                             timevar = "environment", v.names = "predictedValue", sep= "")
      colnames(wide) <- gsub("predictedValue","",colnames(wide))
      wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
      corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
      vv <- cgiarBase::matToTab(corr)
      p <- ggplot2::ggplot(data = vv, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white", 
                                      midpoint = 0, limit = c(-1,1), space = "Lab", 
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+ 
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 8, hjust = 1))+
        # ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 8, hjust = 1))+
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) + 
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed()
      # p
      plotly::ggplotly(p)
    })
    
    
  }
  
}
```

Connectivity between the environments

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  
  idSta <- modelingAbi[modelingAbi$parameter == "sta", "value"]
  idMta <- modelingAbi[modelingAbi$parameter == "mta", "value"]
  pred <- result$predictions
  pred <- pred[pred$analysisId == idMta,]
  traits <- unique(result$modeling[which(result$modeling$analysisId == idMta  & result$modeling$environment == "across"),"trait"]) # unique(pred$trait)
  modeling <- result$modeling
  modelingFieldsIncludedInMta <- modeling[modeling$analysisId == idMta & modeling$parameter == "includedInMta", ]
  traitsMta <- modeling[which(modeling$analysisId == idMta),"trait"]
  traitsMta <- setdiff(traitsMta, "inputObject")
   
  if("params" %in% ls()){ # we will download the document
    
  }else{
    selectInput(ns("traitMtaConnect"), 
                label = "", 
                choices = traitsMta
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  mydataConnect <- result$predictions
  mydataConnect <- mydataConnect[mydataConnect$analysisId == idSta, ]
  
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###  {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traitsMta){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == iTrait, "environment"]
      mydata2 <- mydataConnect[which(mydataConnect$trait == iTrait & mydataConnect$environment %in% goodFields), ]
      splitAggregate <- with(mydata2,  split(mydata2[,"designation"],mydata2[,"environment"]) ) # split by environment
      splitAggregate <- lapply(splitAggregate,unique); nag <- length(splitAggregate) # get unique individual names
      nagm <- matrix(0,nag,nag); rownames(nagm) <- colnames(nagm) <- names(splitAggregate) # prefilled matrix
      for(i in 1:length(splitAggregate)){ # fill the matrix of intersection of individuals between pair of environments
        for(j in 1:i){
          nagm[i,j] <- length(intersect(splitAggregate[[i]],splitAggregate[[j]]))
        }
      }
      nagm[upper.tri(nagm)] <- t(nagm)[upper.tri(nagm)] # fill the upper triangular
      
      mydata4 <- cgiarBase::matToTab(nagm) # matrix to a dataframe for plot
      maxVal <- max(nagm, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "firebrick", high = "#038542", mid = "gold",
                                      midpoint = 60, limit = c(0,maxVal), space = "Lab",
                                      name="Connectivity") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() + 
        ggplot2::coord_fixed() + 
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 7, hjust = 1, color="black"))+
        # ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 7, hjust = 1, color="black"))
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank() ) 
      if(nrow(nagm) < 15){ # if user wants to add text to the cells
        p <- p + ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 4)
      }
      # print(p) # static
      print(htmltools::tagList(plotly::ggplotly(p))) # dynamic
      
    }
    
  } else{ # display in website
    
    # shiny::renderPlot({ # static
    plotly::renderPlotly({ # dynamic
      goodFields <- modelingFieldsIncludedInMta[modelingFieldsIncludedInMta$value == "TRUE" & modelingFieldsIncludedInMta$trait == input$traitMtaConnect, "environment"]
      mydata2 <- mydataConnect[which(mydataConnect$trait == input$traitMtaConnect & mydataConnect$environment %in% goodFields), ]
      splitAggregate <- with(mydata2,  split(mydata2[,"designation"],mydata2[,"environment"]) ) # split by environment
      splitAggregate <- lapply(splitAggregate,unique); nag <- length(splitAggregate) # get unique individual names
      nagm <- matrix(0,nag,nag); rownames(nagm) <- colnames(nagm) <- names(splitAggregate) # prefilled matrix
      for(i in 1:length(splitAggregate)){ # fill the matrix of intersection of individuals between pair of environments
        for(j in 1:i){
          nagm[i,j] <- length(intersect(splitAggregate[[i]],splitAggregate[[j]]))
        }
      }
      nagm[upper.tri(nagm)] <- t(nagm)[upper.tri(nagm)] # fill the upper triangular
      
      mydata4 <- cgiarBase::matToTab(nagm) # matrix to a dataframe for plot
      maxVal <- max(nagm, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
      p <- ggplot2::ggplot(data = mydata4, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "firebrick", high = "#038542", mid = "gold",
                                      midpoint = 60, limit = c(0,maxVal), space = "Lab",
                                      name="Connectivity") +
        ggplot2::theme_minimal()+
        ggplot2::ylab("") + ggplot2::xlab("") +
        ggplot2::coord_fixed() + 
        ggplot2::coord_fixed() + 
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 7, hjust = 1, color="black", face = "bold"))+
        # ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 7, hjust = 1, color="black", face="bold"))
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank() )
      if(nrow(nagm) < 15){ # if user wants to add text to the cells
        p <- p + ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 4)
      }
      # print(p) # static
      plotly::ggplotly(p) #dynamic
    })
    
  }
  
}
```

### Trait view

The following graphs aim to sow the genetic correlation between traits using across environment estimates of genetic merit. In addition, the radar plot displays the population means and the target values for the product profile to show the differences between these two and see how big are the gaps.


### Selection results

The following graph display the expected gain after the selection of parents and crosses for the next generation. The density plots show the base population (red), the selected population of parents (blue), and the predicted distribution of the crosses to be made (green). The distribution of selected parents and future crosses come from the optimal cross selection (OCS) run.


### Selection history

The following graph shows the realized genetic gain for this pipeline. The x-axis represents the year of origin or release of the material and the y-axis represents the trait value.


