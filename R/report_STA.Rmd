---
title: "`r params$doc_title`"
subtitle: "`r params$doc_subtitle`"
author: "Biometrics Group OneCGIAR"
date: "`r format(Sys.time(), '%B %d, %Y')`"  
# date last modified: March 9, 2023

params:
  # data_original: NULL
  data_rds_sta: "result.rds"
  # data_original: !r read.csv(here::here(paste0("data/misc/DataAYT-SEN-FN-ND-DS-TR-2022.csv")))
  # data_rds_clp: !r readRDS(here::here(paste0("data/misc/clpclp2023.02.27.14.37.11.pv_BD_CG_CM_BRRI-2022-Wet-001_Plot_List_20230227_025910.rds")))
  # data_rds_sta: !r readRDS(here::here("data/misc/sta2023.02.28.03.10.13.jangh_BD_CG_CM_BRRI-2022-Wet-001_Plot_List_20230227_025910.rds"))
  doc_title: "Single-Trial Analysis"
  doc_subtitle: ""
  # is_full_report: TRUE
  # is_extended_report: TRUE
output: 
  rmdformats::robobook:
  # html_document:
    # toc: TRUE
    toc_depth: 4
    # toc_float:
    #   collapsed: FALSE
    #   smooth_scroll: FALSE
---

<style>
.main-container {
  max-width: 200%;
  margin-left: 0;
  margin-right: 0;
}
.tab-content {
  margin-bottom: 50px;
}
.book .book-body .page-inner {
  max-width: 2000px;
}
</style>

```{r setup, include = FALSE}

# knitr R markdown chunk options
knitr::opts_chunk$set(dependson = knitr::all_labels(),
                      include = TRUE,
                      echo = FALSE,
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      comment = NA,
                      out.width = "100%",
                      error = TRUE)
options(knitr.kable.NA = '', knitr.duplicate.label = "allow")

# loading necessary R packages ####
## data manipulation
library(dplyr)      # %>%, data cleaning functions
library(tidyr)      # pivot_()
library(magrittr)   # %<>%, coerce col to factors or numeric
library(stringr)    # str_detect()
library(scales)     # rescale data between to values

## outputs - graphs, tables
library(ggplot2)    # ggplot(), etc.
library(DT)         # datatable()
library(knitr)      # kable()
library(kableExtra) # kable_styling(), etc.
library(viridis)    # scale_fill_viridis()
library(corrplot)   # corrplot()
library(gge)        # gge(), biplot()
library(plotly)     # ggplotly()
library(htmltools)  # tagList()

```


```{r printfxn, include = FALSE}
# functions ####
# for printing tables (data.frames) - DT::datatable()
printTable <- function(DT, pageLength = 5, 
                       numericColNames = NULL, numRound = 4, 
                       scrollXOpt = FALSE, ...) {
  
  DT <- data.frame(lapply(X = DT, 
                          FUN = function(x) {
                            if(is.numeric(x)){
                              round(x, numRound)
                            } else {
                              x
                            }
                          }))
  
  table <- DT::datatable(data = DT, 
                         filter = "top", 
                         options = list(autoWidth = TRUE, 
                                        dom = '<"pull-right"l>tpBi',# dom = '<<"pull-right"l><t>pB>i'
                                        buttons = c('copy', 'csv', 'excel'),
                                        pageLength = pageLength,
                                        searchHighlight = TRUE,
                                        lengthMenu = c(5, 10, 15, 20),
                                        scrollX = scrollXOpt),
                         extensions = 'Buttons',
                         rownames = FALSE,
                         # style = "bootstrap",
                         ...)
  if (length(numericColNames) > 0){
    table <- table %>% formatRound(columns = numericColNames,
                                   digits = numRound)
  }
  
  table
}
```

<!-- ***   -->

<!-- ## Data Preview -->

```{r data, error = FALSE}
# loading the dataset ----
# done outside the RMD

# checking
# stopifnot(!is.null(params$data_original),
stopifnot(!is.null(params$data_rds_sta))

# dt_orig <- params$data_original
dt_sta <- readRDS(params$data_rds_sta)

# printTable(rbind(head(dt_orig, 5), tail(dt_orig, 5)),
#            caption = "Preview of the Original Dataset")

dt_clean <- dt_sta$data$pheno

# printTable(rbind(head(dt_clean, 5), tail(dt_clean, 5)),
#            caption = "Preview of the Cleaned Dataset")


```


***


## Trial Overview

<div style = "width:100%; height:auto;">
```{r summary1}

overview_vars <- c("year", "season", "location", "country", "trial", "environment")


overview_vars_label <- gsub("F$", "", overview_vars) # str_to_title(gsub("F$", "", overview_vars))
summary_list <- vector(mode = "list", length = length(overview_vars))
names(summary_list) <- overview_vars

for (i in seq_along(overview_vars)) {
  dt_clean[, overview_vars[i]] <- as.factor(dt_clean[, overview_vars[i]])
  summary_temp <- paste0(levels(dt_clean[, overview_vars[i]]), collapse = ", ")
  summary_temp <- ifelse(length(grep("^dummy_", summary_temp)) != 0, "", summary_temp)
  summary_list[[i]] <- summary_temp
}

traits <- unique(dt_sta$modeling$trait)
if (summary_list$trial != "") {
  trials <- levels(dt_clean[, "trial"])
  trialVar <- "trial"
} else {
  trials <- levels(dt_clean[, "environment"])
  trialVar <- "environment"
}

summaryInfo1 <- tribble(
  ~cat, ~val,
  # "**Experimental design(s)**", paste0(unique(mydata[, params$design]),
  #                                      collapse = ", "),
  "**Traits**", paste0(traits, collapse = ", "),
  "**TimePoints**", summary_list[[1]], # time point or year depeding on input
  "**Seasons**", summary_list$season,
  "**Countries**", summary_list$country,
  "**Locations**", summary_list$location,
  "**Number of trials/field instances**", ifelse(summary_list$trial != "", as.character(length(unique(dt_clean[, "trial"]))), as.character(length(unique(dt_clean[, "environment"])))),
  # "**Number of environment**", ifelse(summary_list$environment != "", as.character(length(levels(dt_clean[, "environment"]))), ""),
  "**Number of entries**", as.character(length(unique(dt_clean[, "designation"])))
  
)


names(summaryInfo1) <- c("", "")
kable(summaryInfo1) %>% kable_styling(full_width = F, position = "float_left")

```
</div>


```{r overview}

dt_clp_timePoint <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "year")]
dt_clp_season <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "season")]
dt_clp_location <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "location")]
dt_clp_trial <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "trial")]

grouping_vars <- !is.na(c(dt_clp_timePoint, dt_clp_season, dt_clp_location, dt_clp_trial)) & c(dt_clp_timePoint, dt_clp_season, dt_clp_location, dt_clp_trial) != "ABSENT"

theTime <- "year"

grouping_vars_2 <- c("environment", c(theTime, "season", "location", "trial")[grouping_vars])
grouping_vars_2_label <- str_to_title(gsub("F$", "", grouping_vars_2))

# remove all "dummy"s
remove_dummy <- function(DT, col) {
  while (length(grep("*dummy_*", unique(DT[, col]))) > 0) {
    DT <- DT %>% 
      mutate({{col}} := gsub("dummy_[a-zA-Z]*_", "", DT[, col])) %>% 
      mutate({{col}} := gsub("_dummy_[a-zA-Z]*", "", DT[, col]))
  }
  return(DT)
}

dt_clean <- remove_dummy(dt_clean, "environment")


dt_clean <- dt_clean %>% mutate(environment = as.factor(environment))

trial_overview <- dt_clean %>%
  group_by(across(all_of(grouping_vars_2))) %>%
  summarize(NumEntries = n_distinct(designation))

names(trial_overview)[1:length(grouping_vars_2_label)] <- grouping_vars_2_label

printTable(trial_overview,
           caption = paste0("List of field instance(s)/trial(s) & year(s)/season(s)/location(s) and the total number of entries"))


# trial_overview_2 <- dt_clean %>%
#   group_by(across(all_of(c(grouping_vars_2, "designation")))) %>% 
#   count()
#   summarize(across(all_of(traits), list(NumEntries = ())))
# 
# names(trial_overview_2)[1:length(grouping_vars_2_label)] <- grouping_vars_2_label
# 
# printTable(trial_overview_2,
#            caption = paste0("List of field instance(s)/trial(s) & year(s)/season(s)/location(s) and the total number of non-missing entries per trait"))

```


### Numerical Descriptive Measures  

```{r descStats}
descStatTemp <- list()

for (i in 1:length(traits)) {
  
  if (!traits[i] %in% names(dt_clean)) next
  
  descStatTemp[[i]] <- dt_clean %>% 
    group_by(across(all_of(grouping_vars_2))) %>% 
    summarize(trait = traits[i],
              n_non_miss = sum(!is.na(get(traits[i]))), 
              min = min(get(traits[i]), na.rm = T),
              mean = mean(get(traits[i]), na.rm = T),
              max = max(get(traits[i]), na.rm = T),
              stddev = sd(get(traits[i]), na.rm = T))
}

descStat_all <- do.call(rbind.data.frame, descStatTemp)
names(descStat_all)[1:length(grouping_vars_2_label)] <- grouping_vars_2_label

printTable(descStat_all, 
           numericColNames = c("min", "mean", "max", "stddev"))

```

&nbsp;  

```{r plot_init, include = FALSE}
# Init Step to make sure that the dependencies are loaded
# was done to enable proper printing of the tab header and the graphs within the for loop below using print(htmltools::tagList(ggplotly(...)))
htmltools::tagList(ggplotly(ggplot()))

# Get the current figure size in pixels:
get_w <- function() {
  with(knitr::opts_current$get(c("fig.width", "dpi", "fig.retina")),
       fig.width*dpi/fig.retina)
}

get_h <- function() {
  with(knitr::opts_current$get(c("fig.height", "dpi", "fig.retina")),
       fig.height*dpi/fig.retina)
}


```


```{r boxplot, results = 'asis', fig.height = 6}

# Boxplots ----
asis_output(paste0("### Boxplots {.tabset .tabset-pills}    \n\n  "))

numTraits <- length(traits)
# ggplot_boxplots_cleaned <- vector(mode = "list", length = numTraits)
plotly_boxplots_cleaned <- vector(mode = "list", length = numTraits)

# xlabel <- "environment"
xlabel <- gsub("F$", "", trialVar)

# Visualization
for (i in 1:numTraits) {
  
  if (!traits[i] %in% names(dt_clean)) next
  
  cat("\n\n")
  cat("#### ", traits[i], "  \n  ")
  
  # plot.new()
  
  # ggplot_boxplots_cleaned[[i]] <- ggplot(data = dt_clean,
  #                                        mapping = aes(x = environment,
  #                                                      y = get(traits[i]),
  #                                                      fill = environment)) +
  #   geom_boxplot() +
  #   scale_fill_viridis(discrete = TRUE, alpha = 0.6) +
  #   labs(title = paste0("Distribution of ", traits[i], " for each field instance"),
  #        fill = "environment") +
  #   theme_classic() +
  #   theme(legend.position = "none") + 
  #   scale_x_discrete(guide = guide_axis(
  #     angle = ifelse(nlevels(dt_clean[, "environment"]) > 5 ||
  #                      max(sapply(levels(dt_clean$environment), nchar)) > 20, 20, 0))) +
  #   ylab(traits[i]) +
  #   xlab(xlabel)
  # # if (nlevels(dt_clean[, "environment"]) > 5 || max(sapply(levels(dt_clean$environment), nchar)) > 20)
  # #   ggplot_boxplots_cleaned[[i]] <- ggplot_boxplots_cleaned[[i]] + coord_flip()
  # 
  # plot(ggplot_boxplots_cleaned[[i]])
  
  plotly_boxplots_cleaned[[i]] <- ggplot(data = dt_clean,
                                         mapping = aes(x = get(trialVar),
                                                       y = get(traits[i]),
                                                       fill = get(trialVar))) + 
    geom_boxplot() + 
    scale_fill_viridis(discrete = TRUE, alpha = 0.6) + 
    labs(title = paste0("Distribution of ", traits[i], " for each trial/field instance"),
         fill = xlabel) + 
    theme_classic() + 
    theme(legend.position = "none",
          axis.text.x = element_text(angle = ifelse(
            nlevels(dt_clean[, trialVar]) > 5 || 
              max(sapply(levels(dt_clean[, trialVar]), nchar)) > 20, -20, 0))) + 
    ylab(traits[i]) + 
    xlab(xlabel)
  # if (nlevels(dt_clean[, "environment"]) > 5 || max(sapply(levels(dt_clean$environment), nchar)) > 20)
  #   plotly_boxplots_cleaned[[i]] <- plotly_boxplots_cleaned[[i]] + coord_flip()
  
  print(htmltools::tagList(ggplotly(plotly_boxplots_cleaned[[i]], height = get_h())))
  
  cat("\n\n&nbsp;  ")
  
}

trait_GY <- dt_sta$modeling$trait[grep(x = dt_sta$modeling$trait, pattern = "GY|YLD|Yield|yield|YKGH")]
has_GY <- ifelse(length(trait_GY) > 0, TRUE, FALSE)
plot_GY_heatmap <- has_GY && (dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "row")] != "ABSENT") && (dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "col")] != "ABSENT")

```

***  


```{r GY_heatmap, eval = plot_GY_heatmap, results = "asis", fig.height = 7}

asis_output(paste0("### Field Heatmap for Grain Yield {.tabset .tabset-pills}  \n    "))

# heatMapList <- NULL
for (i in seq_along(trials)) {
  # print(i)
  tempDT <- dt_clean %>% filter(trial == trials[i])
  if (nrow(tempDT) == 0 && length(trials) == 1) {
    tempDT <- dt_clean
  } else if (nrow(tempDT) == 0 && length(trials) > 1) {
    tempDT <- dt_clean %>% filter(environment == trials[i])
  }
  
  isMissingAllRowsCols <- nrow(tempDT) == length(which(is.na(tempDT[, "row"]))) &&
    nrow(tempDT) == length(which(is.na(tempDT[, "col"])))
  
  if (isMissingAllRowsCols) {
    
    cat("\n\n")
    cat("#### ", trials[i], "  \n")
    cat("\t\tNote: All row and column values are NAs (missing).\n\n  ")
    
  } else if (!isMissingAllRowsCols) {
    
    cat("\n\n")
    cat("#### ", trials[i], "  \n")
    # plot.new()
    
    # doe <- toupper(unique(tempDT[, params$design]))
    # 
    # # since rep would be specified as the number of times the genotype occurred
    # # and not the block in which that genotype is located
    # if (doe %in% c(exptDsgnsList$augmented_rcbd, exptDsgnsList$p_rep)) {
    #   params_rep <- params$block
    # }
    
    # tempDT$row <- as.numeric(tempDT$row)
    # tempDT$col <- as.numeric(tempDT$col)
    mycol <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "col")]
    myrow <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "row")]
    myrep <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "row")]
    mydesignation <- dt_sta$metadata$pheno$value[which(dt_sta$metadata$pheno$parameter == "designation")]
    
    p <- ggplot(data = tempDT,
                mapping = aes(x = col, y = row)) +
      geom_tile(data = tempDT,
                mapping = aes(
                  fill = get(trait_GY[1]), # color = repF,
                  text = paste(paste0('<br>', ifelse(is.na(mycol) || mycol == "ABSENT",
                                                     "col", mycol), ":"), col,
                               paste0('<br>', ifelse(is.na(myrow) || myrow == "ABSENT",
                                                     "row", myrow), ":"), row,
                               paste0('<br>', ifelse(is.na(mydesignation) || mydesignation == "ABSENT",
                                                     "designation", mydesignation), ":"), designation,
                               paste0('<br>', trait_GY, ":"), get(trait_GY[1]),
                               paste0('<br>', ifelse(is.na(myrep) || myrep == "ABSENT",
                                                     "rep", myrep), ":"), repF)),
                size = 1) +
      # geom_rect(data = tempDT,
      #           mapping = aes(xmin = min(as.numeric(levels(tempDT$col))) - 0.5, 
      #                         xmax = max(as.numeric(levels(tempDT$col))) + 0.5,
      #                         ymin = min(as.numeric(levels(tempDT$row))) - 0.5, 
      #                         ymax = max(as.numeric(levels(tempDT$row))) + 0.5,
      #             fill = get(trait_GY[1]), color = repF,
      #             text = paste(paste0('<br>', ifelse(is.na(mycol),
      #                                                "col", mycol), ":"), col,
      #                          paste0('<br>', ifelse(is.na(myrow),
      #                                                "row", myrow), ":"), row,
      #                          paste0('<br>', ifelse(is.na(mydesignation),
    #                                                "designation", mydesignation), ":"), designation,
    #                          paste0('<br>', trait_GY, ":"), get(trait_GY[1]),
    #                          paste0('<br>', ifelse(is.na(myrep),
    #                                                "rep", myrep), ":"), repF)),
    #           size = 1) +
    scale_fill_gradient(low = "#deffee", high = "#038542") +
      labs(x = "Field columns", y = "Field rows", title = trials[i]) +
      theme(legend.position = "bottom")
    # guides(fill = guide_colourbar(title = trait_GY),
    #        color = guide_legend(title = params_rep))
    p$labels$fill <- trait_GY
    p$labels$colour <- ifelse(is.na(myrep), "rep", myrep)
    
    # heatMapList <- list(heatMapList, ggplotly(p))
    print(htmltools::tagList(ggplotly(p, height = get_h(), tooltip = "text")))
    
    cat("\n\n  ")
    
  }
}
# htmltools::tagList(heatMapList)

```



## Single-Trial Analysis



<!-- ### results per trait & genotype -->
<!-- ```{r trial_quality_1} -->

<!-- dt_sta$predictions <- remove_dummy(dt_sta$predictions, "environment") -->

<!-- printTable(dt_sta$predictions %>% relocate(analysisId, environment, trait, designation, predictedValue, stdError, rel) %>%  -->
<!--              select(-rel),  -->
<!--            caption = paste0("Single-Trial Analysis Results - per trait & genotype")) -->

<!-- ``` -->

<!-- &nbsp;   -->

### metrics per trait & trial/field instance
```{r trial_quality}

dt_sta$metrics <- remove_dummy(dt_sta$metrics, "environment")

printTable(dt_sta$metrics %>% 
             relocate(analysisId, environment, trait, parameter, value, stdError) %>%
             select(-c(analysisId, stdError)), 
           caption = paste0("Single-Trial Analysis Metrics (H2/reliability) - per trait & trial/field instance"))

```

&nbsp;  

***  

These results were generated using the latest version (July 2023) of the analytics R Shiny app. 





